

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第五篇. 嵌入式Linux驱动开发基础知识 &mdash; 嵌入式Linux应用开发完全手册第2版 1.0 文档</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/100ask_net_ico.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="../../genindex.html"/>
        <link rel="search" title="搜索" href="../../search.html"/>
    <link rel="top" title="嵌入式Linux应用开发完全手册第2版 1.0 文档" href="../../index.html"/>
        <link rel="up" title="&lt;no title&gt;" href="index.html"/>
        <link rel="prev" title="&lt;no title&gt;" href="index.html"/>
    <link href="../../_static/default.css" rel="stylesheet" type="text/css">


  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> 嵌入式Linux应用开发完全手册第2版
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapterone/ELADCMSecondEditionChapterOne.html">第一篇. 韦东山全系列视频介绍及资料下载</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chaptertwo/ELADCMSecondEditionChapterTwo.html">第二篇. Linux基本操作与开发工具使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapterthird/ELADCMSecondEditionChapterThird.html">第三篇. 开发板快速上手</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapterfour/ELADCMSecondEditionChapterFour.html">第四篇. 嵌入式Linux应用开发基础知识</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第五篇. 嵌入式Linux驱动开发基础知识</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#font-color-dd0000-linux-font"><font color="#dd0000">嵌入式后Linux驱动开发基础知识</font>的引导与说明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">打算讲什么、怎么讲？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">需要做什么准备工作</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hello">Hello驱动(不涉及硬件操作)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#app">APP打开的文件在内核中如何表示</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-file">打开字符设备节点时，内核中也有对应的struct file</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">请猜猜怎么编写驱动程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">请不要啰嗦，表演你的代码吧</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">写驱动程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">写测试程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">测试</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Hello驱动中的一些补充知识</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-init-module-exit">module_init/module_exit的实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register-chrdev">register_chrdev的内部实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-destroy-device-create">class_destroy/device_create浅析</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#led">硬件知识_LED原理图</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#font-color-dd0000-font"><font color="#dd0000">先来讲讲怎么看原理图</font></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gpio">普适的GPIO引脚操作方法==</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">GPIO模块一般结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">GPIO寄存器操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">GPIO的其他功能：防抖动、中断、唤醒</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id12">具体单板的GPIO操作方法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#am335xgpio">AM335X的GPIO操作方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">AM335X的GPIO模块结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">AM335X的GPIO相关寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-and-clear">set-and-clear协议</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rk3288gpio">RK3288的GPIO操作方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">RK3288的GPIO模块结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">RK3288的GPIO相关寄存器</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rk3399gpio">RK3399的GPIO操作方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id17">RK3399的GPIO模块结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">RK3399的GPIO相关寄存器</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#imx6ullgpio">IMX6ULL的GPIO操作方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id19">IMX6ULL的GPIO模块结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ccmgpio">CCM用于设置是否向GPIO模块提供时钟</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iomuxc-mode">IOMUXC：引脚的模式(Mode、功能)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">GPIO模块内部</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">怎么编程</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id24">LED驱动程序框架</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id25">回顾字符设备驱动程序框架</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id26">对于LED驱动，我们想要什么样的接口？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id27">LED驱动要怎么写，才能支持多个板子？分层。</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id28">写代码</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id29">驱动程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ledled-operations">把LED的操作抽象出一个led_operations结构体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#file-operations">驱动程序的上层：file_operations结构体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id30">测试程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">上机测试</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id32">课后作业</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id33">具体单板的LED驱动程序</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id34">怎么写LED驱动程序？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#am335xled">AM335X的LED驱动程序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id35">原理图</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">所涉及的寄存器操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id37">写程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id38">配置内核去掉原有LED驱动</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id39">课后作业</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rk3288rk3399led">RK3288和RK3399的LED驱动程序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id40">原理图</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id41">所涉及的寄存器操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id42">写程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id43">上机实验</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id46">课后作业</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#imx6ullled">野火/正点原子IMX6ULL的LED驱动程序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id47">原理图</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id48">所涉及的寄存器操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id49">写程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id52">上机实验</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id55">课后作业</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#imx6ull-qemuled">百问网IMX6ULL-QEMU的LED驱动程序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id56">看原理图确定引脚及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id57">所涉及的寄存器操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id58">写程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id59">上机实验</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id60">课后作业</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id61">驱动设计的思想：面向对象/分层/分离</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id62">面向对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id63">分层</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id64">分离</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id65">写示例代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id66">课后作业</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id67">驱动进化之路：总线设备驱动模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id68">驱动编写的3种方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id69">传统写法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id70">总线设备驱动模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id71">设备树</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#linux-bus-dev-drv">在Linux中实现“分离”：Bus/Dev/Drv模型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id72">匹配规则</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#platform-device-driver-overrideplatform-driver-driver-name">最先比较：platform_device. driver_override和platform_driver.driver.name</a></li>
<li class="toctree-l4"><a class="reference internal" href="#platform-device-nameplatform-driver-id-table-i-name">然后比较：platform_device. name和platform_driver.id_table[i].name</a></li>
<li class="toctree-l4"><a class="reference internal" href="#platform-device-nameplatform-driver-driver-name">最后比较：platform_device.name和platform_driver.driver.name</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id73">函数调用关系</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id74">常用函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id75">注册/反注册</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id76">获得资源</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id77">怎么写程序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#platform-device">分配/设置/注册platform_device结构体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#platform-driver">分配/设置/注册platform_driver结构体</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id78">课后作业</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id79">LED模板驱动程序的改造：总线设备驱动模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id80">原来的框架</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id81">要实现的框架===</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id82">写代码</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id83">注意事项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id84">实现platform_device结构体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id85">实现platform_driver结构体</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id86">课后作业</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id87">驱动进化之路：设备树的引入及简明教程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id88">设备树的引入与作用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id89">设备树的语法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#devicetree">Devicetree格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dtsdtsi">dts文件包含dtsi文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id90">常用的属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id91">常用的节点(node)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id93">编译、更换设备树</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#make">在内核中直接make</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id94">手工编译</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id95">给开发板更换设备树文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id96">板子启动后查看设备树</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id97">内核对设备树的处理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dtbdevice-node">dtb中每一个节点都被转换为device_node结构体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id98">哪些设备树节点会被转换为platform_device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id99">怎么转换为platform_device</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#platform-deviceplatform-driver">platform_device如何与platform_driver配对</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#driver">最先比较：是否强制选择某个driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id100">然后比较：设备树信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#platform-device-id">接下来比较：platform_device_id</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id101">最后比较：platform_device.name和platform_driver.driver.name</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id102">一个图概括所有的配对过程</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id103">没有转换为platform_device的节点，如何使用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id104">内核里操作设备树的常用函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id105">内核中设备树相关的头文件介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id107">platform_device相关的函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id108">有些节点不会生成platform_device，怎么访问它们</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id112">怎么修改设备树文件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id113">使用芯片厂家提供的工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id114">看绑定文档</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id115">参考同类型单板的设备树文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id116">网上搜索</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id117">实在没办法时, 只能去研究驱动源码</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id118">LED模板驱动程序的改造：设备树</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id119">总结3种写驱动程序的方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id120">怎么使用设备树写驱动程序</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id121">设备树节点要与platform_driver能匹配</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id122">设备树节点指定资源，platform_driver获得资源</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id123">开始编程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id124">修改设备树添加led设备节点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id131">修改platform_driver的源码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id132">上机实验</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id133">调试技巧</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id134">设备树的信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id135">platform_device的信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id136">platform_driver的信息</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id137">课后作业</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id138">APP怎么读取按键值</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id139">妈妈怎么知道孩子醒了</a></li>
<li class="toctree-l3"><a class="reference internal" href="#app4">APP读取按键的4种方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id140">查询方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id141">休眠-唤醒方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#poll">poll方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id142">异步通知方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id145">驱动程序提供能力，不提供策略</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id146">查询方式的按键驱动程序_编写框架</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id147">LED驱动回顾</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id148">按键驱动编写思路</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id149">编程：先写框架</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#button-operations">把按键的操作抽象出一个button_operations结构体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id150">驱动程序的上层：file_operations结构体</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id151">测试</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id152">课后怎业</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id153">具体单板的按键驱动程序(查询方式)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id154">GPIO操作回顾</a></li>
<li class="toctree-l3"><a class="reference internal" href="#am335x">AM335X的按键驱动程序(查询方式)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id155">先看原理图确定引脚及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id156">再看芯片手册确定寄存器及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id157">编程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id160">测试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id161">课后作业</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id162">RK3288的按键驱动程序(查询方式)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id163">先看原理图确定引脚及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id164">再看芯片手册确定寄存器及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id165">编程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id168">测试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id169">课后作业</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id170">RK3399的按键驱动程序(查询方式)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id171">先看原理图确定引脚及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id172">再看芯片手册确定寄存器及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id173">编程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id176">测试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id177">课后作业</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#imx6ull-qemu">百问网IMX6ULL-QEMU的按键驱动程序(查询方式)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id178">先看原理图确定引脚及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id179">再看芯片手册确定寄存器及操作方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id180">编程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id183">测试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id184">课后作业</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id185">异常与中断的概念及处理流程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id186">中断的引入</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id187">妈妈怎么知道孩子醒了</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id188">嵌入系统中也有类似的情况</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id189">中断的处理流程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id190">异常向量表</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id191">参考资料</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id192">常见问题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#version-magic">安装驱动时version magic不匹配</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">嵌入式Linux应用开发完全手册第2版</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">&lt;no title&gt;</a> &raquo;</li>
      
    <li>第五篇. 嵌入式Linux驱动开发基础知识</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/source/chapterfive/ELADCMSecondEditionChapterFive.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux">
<h1>第五篇. 嵌入式Linux驱动开发基础知识<a class="headerlink" href="#linux" title="永久链接至标题">¶</a></h1>
<div class="section" id="font-color-dd0000-linux-font">
<h2><font color="#dd0000">嵌入式后Linux驱动开发基础知识</font>的引导与说明<a class="headerlink" href="#font-color-dd0000-linux-font" title="永久链接至标题">¶</a></h2>
<div class="section" id="id1">
<h3>打算讲什么、怎么讲？<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<p>  以几个简单的驱动程序，讲解嵌入式Linux驱动的框架，了解驱动开发的流程、方法，掌握从APP到驱动的调用流程。</p>
<p>  会涉及很多种开发板，让你明白“Linux驱动 = 软件框架 + 硬件操作”，让你“一通百通”，掌握了普适性的原理之后，在工作中很容易在其他板子使用这些知识。</p>
<p>  以LED驱动为例，会如下讲解：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_001.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_001.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id2">
<h3>需要做什么准备工作<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>  驱动程序依赖于Linux内核，你为开发板A开发驱动，那就先在Ubuntu中得到、配置、编译开发板A所使用的Linux内核。</p>
<p>  请使用git下载本教程的文档、源码，查看如下目录中你所用开发板的高级用户使用手册(有些开发板的手册我们还没编写完，持续更新)：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_002.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_002.png" />
&lt;600px&gt;</p>
<p>  根据手册完成下面操作：</p>
<p>    硬件部分：</p>
<p>      ① 开发板接线：串口线、电源线、网线</p>
<p>      ② 开发板烧写系统</p>
<p>    软件部分：</p>
<p>      ① 下载Linux内核，Windows和Ubuntu下各放一份</p>
<p>      ② Windows下：使用Source Insight创建内核源码的工程，这是用来浏览内核、编辑驱动</p>
<p>      ③ Ubuntu下：安装工具链，配置、编译Linux内核</p>
<p>      <font color="# dd0000">注意：</font>git的使用方法请参考http://wiki.100ask.net中的“初学者学习路线”：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_003.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_003.png" />
&lt;400px&gt;</p>
</div>
</div>
<div class="section" id="hello">
<h2>Hello驱动(不涉及硬件操作)<a class="headerlink" href="#hello" title="永久链接至标题">¶</a></h2>
<p>  我们选用的内核都是4.x版本，操作都是类似的：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	rk3399   linux <span class="m">4</span>.4.154   
	rk3288   linux <span class="m">4</span>.4.154   
	imx6ul   linux <span class="m">4</span>.9.88   
	am3358  linux <span class="m">4</span>.9.168   
</pre></div>
</div>
<div class="section" id="app">
<h3>APP打开的文件在内核中如何表示<a class="headerlink" href="#app" title="永久链接至标题">¶</a></h3>
<p>  APP打开文件时，可以得到一个整数，这个整数被称为文件句柄。对于APP的每一个文件句柄，在内核里面都有一个“struct file”与之对应。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_004.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_004.png" />
&lt;400px&gt;</p>
<p>  可以猜测，我们使用open打开文件时，传入的flags、mode等参数会被记录在内核中对应的struct file结构体里(f_flags、f_mode)：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	int open<span class="o">(</span>const char *pathname, int flags, mode_t mode<span class="o">)</span><span class="p">;</span>   
</pre></div>
</div>
<p>  去读写文件时，文件的当前偏移地址也会保存在struct file结构体的f_pos成员里。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_005.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_005.png" />
&lt;400px&gt;</p>
</div>
<div class="section" id="struct-file">
<h3>打开字符设备节点时，内核中也有对应的struct file<a class="headerlink" href="#struct-file" title="永久链接至标题">¶</a></h3>
<p>  注意这个结构体中的结构体：struct file_operations *f_op，这是由驱动程序提供的。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_006.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_006.png" />
&lt;400px&gt;</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_007.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_007.png" />
&lt;600px&gt;</p>
<p>  结构体struct file_operations的定义如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_008.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_008.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id3">
<h3>请猜猜怎么编写驱动程序<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>  ① 确定主设备号，也可以让内核分配</p>
<p>  ② 定义自己的file_operations结构体</p>
<p>  ③ 实现对应的drv_open/drv_read/drv_write等函数，填入file_operations结构体</p>
<p>  ④ 把file_operations结构体告诉内核：register_chrdev</p>
<p>  ⑤ 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数</p>
<p>  ⑥ 有入口函数就应该有出口函数：卸载驱动程序时，出口函数调用unregister_chrdev</p>
<p>  ⑦ 其他完善：提供设备信息，自动创建设备节点：class_create, device_create</p>
</div>
<div class="section" id="id4">
<h3>请不要啰嗦，表演你的代码吧<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<div class="section" id="id5">
<h4>写驱动程序<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>  参考driver/char中的程序，包含头文件，写框架，传输数据：</p>
<p>    A. 驱动中实现open, read, write, release，APP调用这些函数时，都打印内核信息</p>
<p>    B. APP调用write函数时，传入的数据保存在驱动中</p>
<p>    C. APP调用read函数时，把驱动中保存的数据返回给APP</p>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
			02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>1_hello_drv<span class="se">\h</span>ello_drv.c   
</pre></div>
</div>
<p>  hello_drv.c源码如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	# include &lt;linux/module.h&gt;   
   
	# include &lt;linux/fs.h&gt;   
	# include &lt;linux/errno.h&gt;   
	# include &lt;linux/miscdevice.h&gt;   
	# include &lt;linux/kernel.h&gt;   
	# include &lt;linux/major.h&gt;   
	# include &lt;linux/mutex.h&gt;   
	# include &lt;linux/proc_fs.h&gt;   
	# include &lt;linux/seq_file.h&gt;   
	# include &lt;linux/stat.h&gt;   
	# include &lt;linux/init.h&gt;   
	# include &lt;linux/device.h&gt;   
	# include &lt;linux/tty.h&gt;   
	# include &lt;linux/kmod.h&gt;   
	# include &lt;linux/gfp.h&gt;   
   
	/* 1. 确定主设备号 */   
	static int major = 0;   
	static char kernel_buf[1024];   
	static struct class *hello_class;   
   
   
	# define MIN(a, b) (a &lt; b ? a : b)   
   
	/* 3. 实现对应的open/read/write等函数，填入file_operations结构体 */   
	static ssize_t hello_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)   
	{   
	    int err;   
	    printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);   
	    err = copy_to_user(buf, kernel_buf, MIN(1024, size));   
	    return MIN(1024, size);   
	}   
   
	static ssize_t hello_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)   
	{   
	    int err;   
	    printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);   
	    err = copy_from_user(kernel_buf, buf, MIN(1024, size));   
	    return MIN(1024, size);   
	}   
   
	static int hello_drv_open (struct inode *node, struct file *file)   
	{   
	    printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);   
	    return 0;   
	}   
   
	static int hello_drv_close (struct inode *node, struct file *file)   
	{   
	    printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);   
	    return 0;   
	}   
   
	/* 2. 定义自己的file_operations结构体 */   
	static struct file_operations hello_drv = {   
	    .owner   = THIS_MODULE,   
	    .open   = hello_drv_open,   
	    .read   = hello_drv_read,   
	    .write   = hello_drv_write,   
	    .release = hello_drv_close,   
	};   
   
	/* 4. 把file_operations结构体告诉内核：注册驱动程序 */   
	/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */   
	static int __init hello_init(void)   
	{   
	    int err;   
   
	    printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);   
	    major = register_chrdev(0, &quot;hello&quot;, &amp;hello_drv);  /* /dev/hello */   
   
   
	    hello_class = class_create(THIS_MODULE, &quot;hello_class&quot;);   
	    err = PTR_ERR(hello_class);   
	    if (IS_ERR(hello_class)) {   
	          printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);   
	          unregister_chrdev(major, &quot;hello&quot;);   
	          return -1;   
	    }   
   
	    device_create(hello_class, NULL, MKDEV(major, 0), NULL, &quot;hello&quot;); /* /dev/hello */   
   
	    return 0;   
	}   
   
	/* 6. 有入口函数就有出口函数：卸载驱动程序时就会去调用这个出口函数 */   
	static void __exit hello_exit(void)   
	{   
	    printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);   
	    device_destroy(hello_class, MKDEV(major, 0));   
	    class_destroy(hello_class);   
	    unregister_chrdev(major, &quot;hello&quot;);   
	}   
   
   
	/* 7. 其他完善：提供设备信息，自动创建设备节点 */   
   
	module_init(hello_init);   
	module_exit(hello_exit);   
   
	MODULE_LICENSE(&quot;GPL&quot;);   
</pre></div>
</div>
<p>  阅读一个驱动程序，从它的入口函数开始，第66行就是入口函数。它的主要工作就是第71行，向内核注册一个file_operations结构体：hello_drv，这就是字符设备驱动程序的核心。</p>
<p>  file_operations结构体hello_drv在第56行定义，里面提供了open/read/write/release成员，应用程序调用open/read/write/close时就会导致这些成员函数被调用。</p>
<p>  file_operations结构体hello_drv中的成员函数都比较简单，大多数只是打印而已。要注意的是，驱动程序和应用程序之间传递数据要使用copy_from_user/copy_to_user函数。</p>
</div>
<div class="section" id="id6">
<h4>写测试程序<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>  测试程序要实现写、读功能：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	A.  ./hello_drv_test  -w  wiki.100ask.net  // 把字符串“wiki.100ask.net”发给驱动程序   
	B.  ./hello_drv_test  -r              // 把驱动中保存的字符串读回来   
</pre></div>
</div>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>1_hello_drv<span class="se">\h</span>ello_drv_test.c   
</pre></div>
</div>
<p>  hello_drv_test.c源码如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cp"># include &lt;sys/types.h&gt;   </span>
	<span class="cp"># include &lt;sys/stat.h&gt;   </span>
	<span class="cp"># include &lt;fcntl.h&gt;   </span>
	<span class="cp"># include &lt;unistd.h&gt;   </span>
	<span class="cp"># include &lt;stdio.h&gt;   </span>
	<span class="cp"># include &lt;string.h&gt;   </span>
	   
	<span class="cm">/*   </span>
<span class="cm">	 * ./hello_drv_test -w abc   </span>
<span class="cm">	 * ./hello_drv_test -r   </span>
<span class="cm">	 */</span>   
	<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>   
	<span class="p">{</span>   
	    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>   
	    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>   
	    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>   
	   
	    <span class="cm">/* 1. 判断参数 */</span>   
	    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>   
	    <span class="p">{</span>   
	          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Usage: %s -w &lt;string&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>   
	          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;      %s -r</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>   
	          <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   
	    <span class="p">}</span>   
	   
	    <span class="cm">/* 2. 打开文件 */</span>   
	    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/hello&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>   
	    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>   
	    <span class="p">{</span>   
	          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;can not open file /dev/hello</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	          <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   
	    <span class="p">}</span>   
	   
	    <span class="cm">/* 3. 写文件或读文件 */</span>   
	    <span class="k">if</span> <span class="p">((</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;-w&quot;</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>   
	    <span class="p">{</span>   
	          <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   
	          <span class="n">len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">?</span> <span class="nl">len</span> <span class="p">:</span> <span class="mi">1024</span><span class="p">;</span>   
	          <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>   
	    <span class="p">}</span>   
	    <span class="k">else</span>   
	    <span class="p">{</span>   
	          <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>   
	          <span class="n">buf</span><span class="p">[</span><span class="mi">1023</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>   
	          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;APP read : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>   
	    <span class="p">}</span>   
	   
	    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>   
	   
	    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="p">}</span>   
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>测试<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>  A.  编写驱动程序的Makefile</p>
<p>    驱动程序中包含了很多头文件，这些头文件来自内核，不同的ARM板它的某些头文件可能不同。所以编译驱动程序时，需要指定板子所用的内核的源码路径。</p>
<p>    要编译哪个文件？这也需要指定，设置obj-m变量即可</p>
<p>    怎么把.c文件编译为驱动程序.ko？这要借助内核的顶层Makefile。</p>
<p>    本驱动程序的Makefile内容如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	01   
	02 #  1. 使用不同的开发板内核时, 一定要修改KERN_DIR   
	03 #  2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:   
	04 #  2.1 ARCH,        比如: export ARCH=arm64   
	05 #  2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-   
	06 #  2.3 PATH,        比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin   
	07 #  注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,   
	08 #      请参考各开发板的高级用户使用手册   
	09   
	10 KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4   
	11   
	12 all:   
	13     make -C $(KERN_DIR) M=`pwd` modules   
	14     $(CROSS_COMPILE)gcc -o hello_drv_test hello_drv_test.c   
	15   
	16 clean:   
	17     make -C $(KERN_DIR) M=`pwd` modules clean   
	18     rm -rf modules.order   
	19     rm -f hello_drv_test   
	20   
	21 obj-m      += hello_drv.o   
</pre></div>
</div>
<p>  先设置好交叉编译工具链，编译好你的板子所用的内核，然后修改Makefile指定内核源码路径，最后即可执行make命令编译驱动程序和测试程序。</p>
<p>  B.  上机实验</p>
<p>    <font color="# dd0000">{{redtext|注意：</font>}}我们是在Ubuntu中编译程序，但是需要在ARM板子上测试。所以需要把程序放到ARM板子上。</p>
<p>    启动单板后，可以通过NFS挂载Ubuntu的某个目录，访问该目录中的程序。</p>
<p>    测试示例：</p>
<p>  ① 在Ubuntu上编译好驱动，并它复制到NFS目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	$ cp *.ko hello_drv_test ~/nfs_rootfs/   
</pre></div>
</div>
<p>  ② 在ARM板上测试：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo &quot;7 4 1 7&quot; &gt; /proc/sys/kernel/printk  // 打开内核的打印信息，有些板子默认打开了   </span>
	<span class="c1">#  ifconfig eth0 192.168.1.100   // 配置ARM板IP，下面是挂载NFS文件系统   </span>
	<span class="c1">#  mount -t nfs -o nolock,vers=3  192.168.1.137:/home/book/nfs_rootfs  /mnt   </span>
	<span class="c1">#  cd  /mnt   </span>
	<span class="c1">#  insmod hello_drv.ko   // 安装驱动程序   </span>
	<span class="o">[</span>  <span class="m">293</span>.594910<span class="o">]</span> hello_drv: loading out-of-tree module taints kernel.   
	<span class="o">[</span>  <span class="m">293</span>.616051<span class="o">]</span> /home/book/source/01_hello_drv/hello_drv.c hello_init line <span class="m">70</span>   
	<span class="c1">#  ls /dev/hello -l      // 驱动程序会生成设备节点   </span>
	crw-------   <span class="m">1</span> root    root     <span class="m">236</span>,   <span class="m">0</span> Jan <span class="m">18</span> <span class="m">08</span>:55 /dev/hello   
	<span class="c1">#  ./hello_drv_test      // 查看测试程序的用法   </span>
	Usage: ./hello_drv_test -w &lt;string&gt;   
	      ./hello_drv_test -r   
	<span class="c1">#  ./hello_drv_test -w wiki.100ask.net   // 往驱动程序中写入字符串   </span>
	<span class="o">[</span>  <span class="m">318</span>.360800<span class="o">]</span> /home/book/source/01_hello_drv/hello_drv.c hello_drv_open line <span class="m">45</span>   
	<span class="o">[</span>  <span class="m">318</span>.372570<span class="o">]</span> /home/book/source/01_hello_drv/hello_drv.c hello_drv_write line <span class="m">38</span>   
	<span class="o">[</span>  <span class="m">318</span>.382854<span class="o">]</span> /home/book/source/01_hello_drv/hello_drv.c hello_drv_close line <span class="m">51</span>   
	<span class="c1">#  ./hello_drv_test -r              // 从驱动程序中读出字符串   </span>
	<span class="o">[</span>  <span class="m">326</span>.177890<span class="o">]</span> /home/book/source/01_hello_drv/hello_drv.c hello_drv_open line <span class="m">45</span>   
	<span class="o">[</span>  <span class="m">326</span>.198304<span class="o">]</span> /home/book/source/01_hello_drv/hello_drv.c hello_drv_read line <span class="m">30</span>   
	APP <span class="nb">read</span> : wiki.100ask.net   
	<span class="o">[</span>  <span class="m">326</span>.214782<span class="o">]</span> /home/book/source/01_hello_drv/hello_drv.c hello_drv_close line <span class="m">51</span>   
   
</pre></div>
</div>
<p>  <font color="# dd0000">注意：</font>如果安装驱动时提示version magic不匹配，请看本文档最后的“常见问题”。</p>
</div>
</div>
<div class="section" id="id8">
<h3>Hello驱动中的一些补充知识<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<div class="section" id="module-init-module-exit">
<h4>module_init/module_exit的实现<a class="headerlink" href="#module-init-module-exit" title="永久链接至标题">¶</a></h4>
</div>
<div class="section" id="register-chrdev">
<h4>register_chrdev的内部实现<a class="headerlink" href="#register-chrdev" title="永久链接至标题">¶</a></h4>
</div>
<div class="section" id="class-destroy-device-create">
<h4>class_destroy/device_create浅析<a class="headerlink" href="#class-destroy-device-create" title="永久链接至标题">¶</a></h4>
</div>
</div>
</div>
<div class="section" id="led">
<h2>硬件知识_LED原理图<a class="headerlink" href="#led" title="永久链接至标题">¶</a></h2>
<p>  当我们学习C语言的时候，我们会写个Hello程序。</p>
<p>  那当我们写ARM程序，也该有一个简单的程序引领我们入门，这个程序就是点亮LED。</p>
<p>  我们怎样去点亮一个LED呢？</p>
<p>  分为三步：</p>
<p>  1.看原理图，确定控制LED的引脚;</p>
<p>  2.看主芯片的芯片手册，确定如何设置控制这个引脚;</p>
<p>  3.写程序;</p>
<div class="section" id="font-color-dd0000-font">
<h3><font color="#dd0000">先来讲讲怎么看原理图</font><a class="headerlink" href="#font-color-dd0000-font" title="永久链接至标题">¶</a></h3>
<p>  LED样子有很多种，像插脚的，贴片的。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_009.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_009.png" />
&lt;400px&gt;</p>
<p>  它们长得完全不一样，因此我们在原理图中将它抽象出来。</p>
<p>  点亮LED需要通电源，同时为了保护LED，加个电阻减小电流。</p>
<p>  控制LED灯的亮灭，可以手动开关LED，但在电子系统中，不可能让人来控制开关，通过编程，利用芯片的引脚去控制开关。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_010.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_010.png" />
&lt;400px&gt;</p>
<p>  LED的驱动方式，常见的有四种。</p>
<p>    方式1：使用引脚输出3.3V点亮LED，输出0V熄灭LED。</p>
<p>    方式2：使用引脚拉低到0V点亮LED，输出3.3V熄灭LED。</p>
<p>  有的芯片为了省电等原因，其引脚驱动能力不足，这时可以使用三极管驱动。</p>
<p>    方式3：使用引脚输出1.2V点亮LED，输出0V熄灭LED。</p>
<p>    方式4：使用引脚输出0V点亮LED，输出1.2V熄灭LED。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_011.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_011.png" />
&lt;600px&gt;</p>
<p>  由此，主芯片引脚输出高电平/低电平，即可改变LED状态，而无需关注GPIO引脚输出的是3.3V还是1.2V。</p>
<p>  所以简称输出1或0：</p>
<p>    逻辑1–&gt;高电平</p>
<p>    逻辑0–&gt;低电平</p>
</div>
</div>
<div class="section" id="gpio">
<h2>普适的GPIO引脚操作方法==<a class="headerlink" href="#gpio" title="永久链接至标题">¶</a></h2>
<p>  GPIO: General-purpose input/output，通用的输入输出口</p>
<div class="section" id="id9">
<h3>GPIO模块一般结构<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>  a.有多组GPIO，每组有多个GPIO</p>
<p>  b.使能：电源/时钟</p>
<p>  c.模式(Mode)：引脚可用于GPIO或其他功能</p>
<p>  d.方向：引脚Mode设置为GPIO时，可以继续设置它是输出引脚，还是输入引脚</p>
<p>  e.数值：对于输出引脚，可以设置寄存器让它输出高、低电平</p>
<p>    对于输入引脚，可以读取寄存器得到引脚的当前电平</p>
</div>
<div class="section" id="id10">
<h3>GPIO寄存器操作<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>  a.芯片手册一般有相关章节，用来介绍：power/clock</p>
<p>    可以设置对应寄存器使能某个GPIO模块(Module)</p>
<p>    有些芯片的GPIO是没有使能开关的，即它总是使能的</p>
<p>  b.一个引脚可以用于GPIO、串口、USB或其他功能，</p>
<p>    有对应的寄存器来选择引脚的功能</p>
<p>  c.对于已经设置为GPIO功能的引脚，有方向寄存器用来设置它的方向：输出、输入</p>
<p>  d.对于已经设置为GPIO功能的引脚，有数据寄存器用来写、读引脚电平状态</p>
<p>    GPIO寄存器的2种操作方法：</p>
<p>      原则：不能影响到其他位</p>
<p>  a.直接读写：读出、修改对应位、写入</p>
<p>    要设置bit n：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="nv">val</span> <span class="o">=</span> data_reg<span class="p">;</span>   
		<span class="nv">val</span> <span class="o">=</span> val <span class="p">|</span> <span class="o">(</span><span class="m">1</span>&lt;&lt;n<span class="o">)</span><span class="p">;</span>   
		<span class="nv">data_reg</span> <span class="o">=</span> val<span class="p">;</span>   
</pre></div>
</div>
<p>    要清除bit n：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="nv">val</span> <span class="o">=</span> data_reg<span class="p">;</span>   
		<span class="nv">val</span> <span class="o">=</span> val <span class="p">&amp;</span> ~<span class="o">(</span><span class="m">1</span>&lt;&lt;n<span class="o">)</span><span class="p">;</span>   
		<span class="nv">data_reg</span> <span class="o">=</span> val<span class="p">;</span>   
</pre></div>
</div>
<p>  b.set-and-clear protocol：</p>
<p>    set_reg, clr_reg, data_reg 三个寄存器对应的是同一个物理寄存器,</p>
<p>    要设置bit n：set_reg = (1&lt;&lt;n);</p>
<p>    要清除bit n：clr_reg = (1&lt;&lt;n);</p>
</div>
<div class="section" id="id11">
<h3>GPIO的其他功能：防抖动、中断、唤醒<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>  后续章节再介绍</p>
</div>
</div>
<div class="section" id="id12">
<h2>具体单板的GPIO操作方法<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>  请使用GIT下载文档后，看下图红框所示目录中各板子对应的文档及图片。</p>
<p>  网盘中相同名字的目录下也有对应的视频。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_012.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_012.png" /></p>
<p>  为方便学习，在本文档中也把上述GIT目录中的文档添加进来了。</p>
<div class="section" id="am335xgpio">
<h3>AM335X的GPIO操作方法<a class="headerlink" href="#am335xgpio" title="永久链接至标题">¶</a></h3>
<p>  GPIO: General-purpose input/output，通用的输入输出口</p>
<p>  PRCM: Power, Reset, and Clock Management (电源、复位、时钟管理器)</p>
<p>  CM: Control Module(控制模块)  或 Clock Module (时钟模块)</p>
<p>  PRM_PER: Power Reset Module Peripheral Registers(电源/复位模块中关于外设的寄存器)</p>
<p>  CM_PER: Clock Module Peripheral Registers (时钟模块中关于外设的寄存器)</p>
<div class="section" id="id13">
<h4>AM335X的GPIO模块结构<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_013.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_013.png" />
&lt;800px&gt;</p>
<p>  有4组GPIO（GPIO0～3），每组有32个GPIO。</p>
<p>  GPIO的控制涉及3大模块：PRCM、Control Module、GPIO模块本身。</p>
<p>  ① PRCM用于使能模块：</p>
<p>    GPIO0永远都是使能的，GPIO1～3可单独控制。</p>
<p>    PRCM模块给GPIO模块常供电，只需要使能GPIO模块的时钟。</p>
<p>  ② Control Module用于设置模式(Mode)：</p>
<p>    设置引脚的Mode(即选择功能)、上下拉电阻等；</p>
<p>    每一个GPIO引脚在Control Module中都有一个寄存器，怎么找到这个寄存器？</p>
<p>      a. 根据pin number确定pin name</p>
<p>    b. 根据pin name在Control Module中确定寄存器</p>
<p>  ③ GPIO模块内部：</p>
<p>    方向：引脚Mode设置为GPIO时，可以继续设置它是输出引脚，还是输入引脚。</p>
<p>    数值：对于输出引脚，可以设置寄存器让它输出高、低电平；</p>
<p>      对于输入引脚，可以读取寄存器得到引脚的当前电平。</p>
</div>
<div class="section" id="id14">
<h4>AM335X的GPIO相关寄存器<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_014.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_014.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="set-and-clear">
<h4>set-and-clear协议<a class="headerlink" href="#set-and-clear" title="永久链接至标题">¶</a></h4>
<p>  假设某个GPIO被设置为输出，怎么设置它的输出电平呢？AM335X中对于每个GPIO模块有一个GPIO_DATAOUT寄存器，其中的每一位对应一个引脚，如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_015.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_015.png" />
&lt;600px&gt;</p>
<p>  要设置某一位时，不能影响到其他位，操作方法是：读出原来的值，修改某一位，把新值写回去。需要3个步骤才可以设置某一位的值，这效率太低了！</p>
<p>  使用set-and-clear可以只用一个步骤即可修改某一位的值。</p>
<p>  当想设置某一位为1时，往DATA_SETDATAOUT寄存器中某位写入1即可，芯片内部会把对应引脚的电平设置为1，并且不会影响其他引脚：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_016.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_016.png" />
&lt;600px&gt;</p>
<p>  当想清除某一位为0时，往DATA_CLEARDATAOUT寄存器中某位写入1即可，芯片内部会把对应引脚的电平设置为0，并且不会影响其他引脚：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_017.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_017.png" />
&lt;600px&gt;</p>
<p>  并非所有的芯片都有set-and-clear功能，TI的AM335X系列芯片有这功能。</p>
</div>
</div>
<div class="section" id="rk3288gpio">
<h3>RK3288的GPIO操作方法<a class="headerlink" href="#rk3288gpio" title="永久链接至标题">¶</a></h3>
<p>  GPIO: General-purpose input/output，通用的输入输出口</p>
<p>  CRU: Clock &amp; Reset Unit (时钟和复位单元)</p>
<p>  PMU: Power Managerment Unit (电源管理单元)</p>
<p>  GRF: General Register Files (通用寄存器文件)</p>
<div class="section" id="id15">
<h4>RK3288的GPIO模块结构<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_018.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_018.png" />
&lt;800px&gt;
  有9组GPIO（GPIO0～8），每组分为最多4个小组port A/B/C/D，每小组最多8个GPIO。理论上每组GPIO的引脚有32个，但是实际上并没有那么多。比如GPIO0只有GPIO0_A0～A7、GPIO0_B0～B7、GPIO0_C0～C2这些引脚。</p>
<p>  GPIO的控制涉及4大模块：CRU、PMU、GRF、GPIO模块本身。</p>
<p>  ① CRU用于设置是否向GPIO模块提供时钟：</p>
<p>    CRU的内部结构如下图所示：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_019.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_019.png" />
&lt;800px&gt;</p>
<p>    可以设置寄存器使能GPIOx的时钟：</p>
<p>      a. CRU_CLKGATE17_CON用于控制GPIO0；</p>
<p>      b. CRU_CLKGATE14_CON用于控制GPIO1～8</p>
<p>  ② PMU用于控制电源：</p>
<p>    电源管理单元里，有多个电源域(power domain，简称为PM)，在一个域下有多个设备。</p>
<p>    比如PD_ALIVE，它下面有这些设备：CRU、GRF、GPIO 1~8、TIMER或WDT。</p>
<p>    比如PD_PMU，它下面有这些设备：PMU、SRAM(4K)、Secure GRF、GPIO0。</p>
<p>    可见，GPIO0、GPIO1~8分属不同的PM。</p>
<p>    GPIO0、GPIO1～8都是常供电的，它们是否工作取决于其时钟是否使能。</p>
<p>  ③ 设置引脚的模式(Mode、功能)：</p>
<p>    GPIO0比较特殊，为了让其引脚用于GPIO功能，要设置PMU里的相关寄存器。</p>
<p>    GPIO1～8类似，为了让其引脚用于GPIO功能，要设置GRF里的相关寄存器。</p>
<p>  ④ GPIO模块内部：</p>
<p>    方向：引脚设置为GPIO时，可以继续设置寄存器GPIO_SWPORTA_DDR确定它是输出引脚，还是输入引脚。</p>
<p>    数值：对于输出引脚，可以设置寄存器GPIO_SWPORTA_DR让它输出高、低电平；</p>
<p>      对于输入引脚，可以读取寄存器GPIO_EXT_PORTA得到引脚的当前电平。</p>
</div>
<div class="section" id="id16">
<h4>RK3288的GPIO相关寄存器<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_020.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_020.png" />
&lt;600px&gt;</p>
</div>
</div>
<div class="section" id="rk3399gpio">
<h3>RK3399的GPIO操作方法<a class="headerlink" href="#rk3399gpio" title="永久链接至标题">¶</a></h3>
<p>  GPIO: General-purpose input/output，通用的输入输出口</p>
<p>  CRU: Clock &amp; Reset Unit (时钟和复位单元)</p>
<p>  PMU: Power Managerment Unit (电源管理单元)</p>
<p>  GRF: General Register Files (通用寄存器文件)</p>
<div class="section" id="id17">
<h4>RK3399的GPIO模块结构<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_021.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_021.png" />
&lt;600px&gt;
  有5组GPIO（GPIO0～4），每组分为最多4个小组port A/B/C/D，每小组最多8个GPIO。理论上每组GPIO的引脚有32个，但是实际上并没有那么多。比如GPIO0只有GPIO0_A0～A7、GPIO0_B0～B5这些引脚。</p>
<p>  GPIO的控制涉及4大模块：CRU、PMU、GRF、GPIO模块本身。</p>
<p>  ① CRU用于设置是否向GPIO模块提供时钟</p>
<p>    a. PMUCRU_CLKGATE_CON1用于控制GPIO0～1；</p>
<p>    b. CRU_CLKGATE_CON31用于控制GPIO2～4</p>
<p>  ② PMU用于控制电源：</p>
<p>    电源管理单元里，有多个电源域(power domain，简称为PM)，在一个域下有多个设备。</p>
<p>    比如PD_ALIVE，它下面有这些设备：CRU、GRF、GPIO 1~4、TIMER或WDT。</p>
<p>    比如PD_PMU，它下面有这些设备：cm0、PMU、SRAM(8K)、Secure GRF、GPIO0、PVTM、I2C。</p>
<p>    可见，GPIO0、GPIO1~4分属不同的PM。</p>
<p>    GPIO0、GPIO1～4都是常供电的。</p>
<p>  ③ 设置引脚的模式(Mode、功能)：</p>
<p>    GPIO0～1比较特殊，为了让其引脚用于GPIO功能，要设置PMU里的相关寄存器。</p>
<p>    GPIO2～4类似，为了让其引脚用于GPIO功能，要设置GRF里的相关寄存器。</p>
<p>  ④ GPIO模块内部：</p>
<p>    方向：引脚设置为GPIO时，可以继续设置寄存器GPIO_SWPORTA_DDR确定它是输出引脚，还是输入引脚。</p>
<p>    数值：对于输出引脚，可以设置寄存器GPIO_SWPORTA_DR让它输出高、低电平；</p>
<p>      对于输入引脚，可以读取寄存器GPIO_EXT_PORTA得到引脚的当前电平。</p>
</div>
<div class="section" id="id18">
<h4>RK3399的GPIO相关寄存器<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_022.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_022.png" />
&lt;600px&gt;</p>
</div>
</div>
<div class="section" id="imx6ullgpio">
<h3>IMX6ULL的GPIO操作方法<a class="headerlink" href="#imx6ullgpio" title="永久链接至标题">¶</a></h3>
<p>  CCM: Clock Controller Module (时钟控制模块)</p>
<p>  IOMUXC : IOMUX Controller，IO复用控制器</p>
<p>  GPIO: General-purpose input/output，通用的输入输出口</p>
<div class="section" id="id19">
<h4>IMX6ULL的GPIO模块结构<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<p>  参考资料：芯片手册《Chapter 26: General Purpose Input/Output (GPIO)》</p>
<p>  有5组GPIO（GPIO1～GPIO5），每组引脚最多有32个，但是可能实际上并没有那么多。</p>
<p>  GPIO1有32个引脚：GPIO1_IO0~GPIO1_IO31；</p>
<p>  GPIO2有22个引脚：GPIO2_IO0~GPIO2_IO21；</p>
<p>  GPIO3有29个引脚：GPIO3_IO0~GPIO3_IO28；</p>
<p>  GPIO4有29个引脚：GPIO4_IO0~GPIO4_IO28；</p>
<p>  GPIO5有12个引脚：GPIO5_IO0~GPIO5_IO11；</p>
<p>  GPIO的控制涉及4大模块：CCM、IOMUXC、GPIO模块本身，框图如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="ccmgpio">
<h4>CCM用于设置是否向GPIO模块提供时钟<a class="headerlink" href="#ccmgpio" title="永久链接至标题">¶</a></h4>
<p>  参考资料：芯片手册《Chapter 18: Clock Controller Module (CCM)》</p>
<p>  GPIOx要用CCM_CCGRy寄存器中的2位来决定该组GPIO是否使能。哪组GPIO用哪个CCM_CCGR寄存器来设置，请看上图红框部分。</p>
<p>  CCM_CCGR寄存器中某2位的取值含义如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" />
&lt;400px&gt;</p>
<p>  ① 00：该GPIO模块全程被关闭</p>
<p>  ② 01：该GPIO模块在CPU run mode情况下是使能的；在WAIT或STOP模式下，关闭</p>
<p>  ③ 10：保留</p>
<p>  ④ 11：该GPIO模块全程使能</p>
<p>    GPIO2时钟控制：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_025.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_025.png" />
&lt;600px&gt;</p>
<p>    GPIO1、GPIO5时钟控制：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_026.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_026.png" />
&lt;600px&gt;</p>
<p>    GPIO3时钟控制：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_027.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_027.png" />
&lt;600px&gt;</p>
<p>    GPIO4时钟控制：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_028.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_028.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="iomuxc-mode">
<h4>IOMUXC：引脚的模式(Mode、功能)<a class="headerlink" href="#iomuxc-mode" title="永久链接至标题">¶</a></h4>
<p>  参考资料：芯片手册《Chapter 32: IOMUX Controller (IOMUXC)》。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_029.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_029.png" />
&lt;100px&gt;</p>
<p>  对于某个/某组引脚，IOMUXC中有2个寄存器用来设置它：</p>
<p>  ① 选择功能：</p>
<p>    IOMUXC_SW_<font color="# dd0000">MUX</font><em>CTL</em><font color="#dd0000">PAD</font>_&lt;<font color="#dd0000">PADNAME</font>&gt; ：Mux pad xxx，选择某个pad的功能</p>
<p>    IOMUXC_SW_<font color="# dd0000">MUX</font><em>CTL</em><font color="#dd0000">GRP</font>_&lt;<font color="#dd0000">GROUP NAME</font>&gt;：Mux grp xxx，选择某组引脚的功能</p>
<p>    某个引脚，或是某组预设的引脚，都有8个可选的模式(alternate (ALT) MUX_MODE)。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_030.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_030.png" />
&lt;400px&gt;</p>
<p>    比如：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_031.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_031.png" />
&lt;600px&gt;</p>
<p>  ② 设置上下拉电阻等参数：</p>
<p>    IOMUXC_SW_<font color="# dd0000">PAD</font><em>CTL</em><font color="#dd0000">PAD</font>_&lt;<font color="#dd0000">PADNAME</font>&gt; ： pad pad xxx，设置某个pad的参数</p>
<p>    IOMUXC_SW_<font color="# dd0000">PAD</font><em>CTL</em><font color="#dd0000">GRP</font>_&lt;<font color="#dd0000">GROUP NAME</font>&gt;：pad grp xxx，设置某组引脚的参数</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_032.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_032.png" />
&lt;400px&gt;</p>
<p>    比如：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_033.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_033.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id20">
<h4>GPIO模块内部<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h4>
<p>  框图如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_034.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_034.png" />
&lt;600px&gt;</p>
<p>  我们暂时只需要关心3个寄存器：</p>
<p>    ① GPIOx_GDIR：设置引脚方向，每位对应一个引脚，1-output，0-input</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_035.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_035.png" />
&lt;600px&gt;</p>
<p>    ② GPIOx_GDIR：设置输出引脚的电平，每位对应一个引脚，1-高电平，0-低电平</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_036.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_036.png" />
&lt;600px&gt;</p>
<p>    ③ GPIOx_PSR：读取引脚的电平，每位对应一个引脚，1-高电平，0-低电平</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_037.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_037.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id21">
<h4>怎么编程<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h4>
<div class="section" id="id22">
<h5>读GPIO<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h5>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_038.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_038.png" />
&lt;600px&gt;
  翻译一下：</p>
<p>    ① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的，上图省略了</p>
<p>    ② 设置IOMUX来选择引脚用于GPIO</p>
<p>    ③ 设置GPIOx_GDIR中某位为0，把该引脚设置为输入功能</p>
<p>    ④ 读GPIOx_DR或GPIOx_PSR得到某位的值（读GPIOx_DR返回的是GPIOx_PSR的值）</p>
</div>
<div class="section" id="id23">
<h5>写GPIO<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h5>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_039.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_039.png" />
&lt;600px&gt;
  翻译一下：</p>
<p>    ① 设置CCM_CCGRx寄存器中某位使能对应的GPIO模块 // 默认是使能的，上图省略了</p>
<p>    ② 设置IOMUX来选择引脚用于GPIO</p>
<p>    ③ 设置GPIOx_GDIR中某位为1，把该引脚设置为输出功能</p>
<p>    ④ 写GPIOx_DR某位的值</p>
<p>      需要注意的是，你可以设置该引脚的loopback功能，这样就可以从GPIOx_PSR中读到引脚的有实电平；你从GPIOx_DR中读回的只是上次设置的值，它并不能反应引脚的真实电平，比如可能因为硬件故障导致该引脚跟地短路了，你通过设置GPIOx_DR让它输出高电平并不会起效果。</p>
</div>
</div>
</div>
</div>
<div class="section" id="id24">
<h2>LED驱动程序框架<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h2>
<p>  <font color="# dd0000">注意：</font>如果做实验安装驱动时提示version magic不匹配，请看本文档最后的“常见问题”。</p>
<div class="section" id="id25">
<h3>回顾字符设备驱动程序框架<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_040.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_040.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id26">
<h3>对于LED驱动，我们想要什么样的接口？<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_041.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_041.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id27">
<h3>LED驱动要怎么写，才能支持多个板子？分层。<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>  1. 把驱动拆分为通用的框架(leddrv.c)、具体的硬件操作(board_X.c)：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_042.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_042.png" />
&lt;600px&gt;</p>
<p>  2. 以面向对象的思想，改进代码：</p>
<p>    抽象出一个结构体：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_043.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_043.png" />
&lt;600px&gt;</p>
<p>    每个单板相关的board_X.c实现自己的led_operations结构体，供上层的leddrv.c调用：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_044.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_044.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id28">
<h3>写代码<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>2_led_drv<span class="se">\0</span>1_led_drv_template   
</pre></div>
</div>
<div class="section" id="id29">
<h4>驱动程序<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h4>
<p>  驱动程序分为上下两层：leddrv.c、board_demo.c。</p>
<p>  leddrv.c负责注册file_operations结构体，它的open/write成员会调用board_demo.c中提供的硬件led_opr中的对应函数。</p>
</div>
<div class="section" id="ledled-operations">
<h4>把LED的操作抽象出一个led_operations结构体<a class="headerlink" href="#ledled-operations" title="永久链接至标题">¶</a></h4>
<p>  首先看看led_opr.h，它定义了一个led_operations结构体，把LED的操作抽象为这个结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	# ifndef _LED_OPR_H   
	# define _LED_OPR_H   
   
	struct led_operations {   
	    int (*init) (int which); /* 初始化LED, which-哪个LED */   
	    int (*ctl) (int which, char status); /* 控制LED, which-哪个LED, status:1-亮,0-灭 */   
	};   
   
	struct led_operations *get_board_led_opr(void);   
   
   
	# endif   
</pre></div>
</div>
</div>
<div class="section" id="file-operations">
<h4>驱动程序的上层：file_operations结构体<a class="headerlink" href="#file-operations" title="永久链接至标题">¶</a></h4>
<p>  上层是leddrv.c，它的核心是file_operations结构体，首先看看入口函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	80 /* 4. 把file_operations结构体告诉内核：注册驱动程序 */   
	81 /* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */   
	82 static int __init led_init(void)   
	83 {   
	84     int err;   
	85     int i;   
	86   
	87     printk(“%s %s line %d\n”, __FILE__, __FUNCTION__, __LINE__);   
	88     major = register_chrdev(0, “100ask_led”, &amp;led_drv);  /* /dev/led */   
	89   
	90   
	91     led_class = class_create(THIS_MODULE, “100ask_led_class”);   
	92     err = PTR_ERR(led_class);   
	93     if (IS_ERR(led_class)) {   
	94           printk(“%s %s line %d\n”, __FILE__, __FUNCTION__, __LINE__);   
	95           unregister_chrdev(major, “led”);   
	96           return -1;   
	97     }   
	98   
	99     for (i = 0; i &lt; LED_NUM; i++)   
	100          device_create(led_class, NULL, MKDEV(major, i), NULL, “100ask_led%d”, i); /* /dev/100ask_led0,1,… */   
	101   
	102    p_led_opr = get_board_led_opr();   
	103   
	104    return 0;   
	105 }   
   
</pre></div>
</div>
<p>  第88行向内核注册一个file_operations结构体。</p>
<p>  第102行从底层硬件相关的代码board_demo.c中获得led_operaions结构体。</p>
<p>  再来看看leddrv.c中file_operations结构体的成员函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">37</span> <span class="cm">/* write(fd, &amp;val, 1); */</span>   
	<span class="mi">38</span> <span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">led_drv_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>   
	<span class="mi">39</span> <span class="p">{</span>   
	<span class="mi">40</span>     <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>   
	<span class="mi">41</span>     <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>   
	<span class="mi">42</span>     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file_inode</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>   
	<span class="mi">43</span>     <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>   
	<span class="mi">44</span>   
	<span class="mi">45</span>     <span class="nf">printk</span><span class="p">(</span><span class="s">&quot;%s %s line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>   
	<span class="mi">46</span>     <span class="n">err</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   
	<span class="mi">47</span>   
	<span class="mi">48</span>     <span class="cm">/* 根据次设备号和status控制LED */</span>   
	<span class="mi">49</span>     <span class="n">p_led_opr</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">(</span><span class="n">minor</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>   
	<span class="mi">50</span>   
	<span class="mi">51</span>     <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>   
	<span class="mi">52</span> <span class="p">}</span>   
	<span class="mi">53</span>   
	<span class="mi">54</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">led_drv_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>   
	<span class="mi">55</span> <span class="p">{</span>   
	<span class="mi">56</span>     <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>   
	<span class="mi">57</span>   
	<span class="mi">58</span>     <span class="nf">printk</span><span class="p">(</span><span class="s">&quot;%s %s line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>   
	<span class="mi">59</span>     <span class="cm">/* 根据次设备号初始化LED */</span>   
	<span class="mi">60</span>     <span class="n">p_led_opr</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">minor</span><span class="p">);</span>   
	<span class="mi">61</span>   
	<span class="mi">62</span>     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">63</span> <span class="p">}</span>   
	<span class="mi">64</span>   
	<span class="mi">65</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">led_drv_close</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>   
	<span class="mi">66</span> <span class="p">{</span>   
	<span class="mi">67</span>     <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %s line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>   
	<span class="mi">68</span>     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">69</span> <span class="p">}</span>   
	<span class="mi">70</span>   
	<span class="mi">71</span> <span class="cm">/* 2. 定义自己的file_operations结构体 */</span>   
	<span class="mi">72</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">led_drv</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">73</span>     <span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>   
	<span class="mi">74</span>     <span class="p">.</span><span class="n">open</span>   <span class="o">=</span> <span class="n">led_drv_open</span><span class="p">,</span>   
	<span class="mi">75</span>     <span class="p">.</span><span class="n">read</span>   <span class="o">=</span> <span class="n">led_drv_read</span><span class="p">,</span>   
	<span class="mi">76</span>     <span class="p">.</span><span class="n">write</span>   <span class="o">=</span> <span class="n">led_drv_write</span><span class="p">,</span>   
	<span class="mi">77</span>     <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">led_drv_close</span><span class="p">,</span>   
	<span class="mi">78</span> <span class="p">};</span>   
   
</pre></div>
</div>
<p>  第49行、第60行，会调用led_operations结构体中对应的函数。</p>
</div>
<div class="section" id="id30">
<h4>测试程序<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h4>
<p>  测试程序为ledtest.c：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cp"># include &lt;sys/types.h&gt;   </span>
	<span class="cp"># include &lt;sys/stat.h&gt;   </span>
	<span class="cp"># include &lt;fcntl.h&gt;   </span>
	<span class="cp"># include &lt;unistd.h&gt;   </span>
	<span class="cp"># include &lt;stdio.h&gt;   </span>
	<span class="cp"># include &lt;string.h&gt;   </span>
   
	<span class="cm">/*   </span>
<span class="cm">	 * ./ledtest /dev/100ask_led0 on   </span>
<span class="cm">	 * ./ledtest /dev/100ask_led0 off   </span>
<span class="cm">	 */</span>   
	<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>   
	<span class="p">{</span>   
	    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>   
	    <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>   
   
	    <span class="cm">/* 1. 判断参数 */</span>   
	    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>   
	    <span class="p">{</span>   
	          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Usage: %s &lt;dev&gt; &lt;on | off&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>   
	          <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   
	    <span class="p">}</span>   
   
	    <span class="cm">/* 2. 打开文件 */</span>   
	    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span><span class="p">);</span>   
	    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>   
	    <span class="p">{</span>   
	          <span class="n">printf</span><span class="p">(</span><span class="s">&quot;can not open file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>   
	          <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   
	    <span class="p">}</span>   
   
	    <span class="cm">/* 3. 写文件 */</span>   
	    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;on&quot;</span><span class="p">))</span>   
	    <span class="p">{</span>   
	          <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   
	          <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   
	    <span class="p">}</span>   
	    <span class="k">else</span>   
	    <span class="p">{</span>   
	          <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
	          <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   
	    <span class="p">}</span>   
   
	    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>   
   
	    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="p">}</span>   
</pre></div>
</div>
<p>  第26行打开设备节点。</p>
<p>  如果用户想点亮LED，第37行会把值“1”通过write函数写入驱动程序。</p>
<p>  如果用户想熄灭LED，第42行会把值“0”通过write函数写入驱动程序。</p>
</div>
<div class="section" id="id31">
<h4>上机测试<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h4>
<p>  这只是一个示例程序，还没有真正操作硬件。测试程序操作驱动程序时，只会导致驱动程序中打印信息。</p>
<p>  首先设置交叉工具链，修改驱动Makefile中内核的源码路径，编译驱动和测试程序。</p>
<p>  启动开发板后，通过NFS访问编译好驱动程序、测试程序，就可以在开发板上如下操作了：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  insmod 100ask_led.ko   // 装载驱动程序   </span>
	<span class="o">[</span><span class="m">13449</span>.134044<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/leddrv.c led_init line <span class="m">87</span>   
	<span class="c1">#  ls /dev/100ask_led* -l   // 可以得到2个设备节点   </span>
	crw-------   <span class="m">1</span> root    root     <span class="m">235</span>,   <span class="m">0</span> Jan <span class="m">18</span> <span class="m">12</span>:34 /dev/100ask_led0   
	crw-------   <span class="m">1</span> root    root     <span class="m">235</span>,   <span class="m">1</span> Jan <span class="m">18</span> <span class="m">12</span>:34 /dev/100ask_led1   
	<span class="c1">#  ./ledtest /dev/100ask_led0 on   // 点亮LED   </span>
	<span class="o">[</span><span class="m">13463</span>.176987<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/leddrv.c led_drv_open line <span class="m">58</span>   
	<span class="o">[</span><span class="m">13463</span>.197877<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/board_demo.c board_demo_led_init line <span class="m">22</span>, led <span class="m">0</span>   
	<span class="o">[</span><span class="m">13463</span>.216232<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/leddrv.c led_drv_write line <span class="m">45</span>   
	<span class="o">[</span><span class="m">13463</span>.232889<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/board_demo.c board_demo_led_ctl line <span class="m">28</span>, led <span class="m">0</span>, on   // 可以看到这句“on”打印   
	<span class="o">[</span><span class="m">13463</span>.247977<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/leddrv.c led_drv_close line <span class="m">67</span>   
	<span class="c1">#  ./ledtest /dev/100ask_led0 off    // 熄灭LED   </span>
	<span class="o">[</span><span class="m">13464</span>.540637<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/leddrv.c led_drv_open line <span class="m">58</span>   
	<span class="o">[</span><span class="m">13464</span>.554380<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/board_demo.c board_demo_led_init line <span class="m">22</span>, led <span class="m">0</span>   
	<span class="o">[</span><span class="m">13464</span>.569671<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/leddrv.c led_drv_write line <span class="m">45</span>   
	<span class="o">[</span><span class="m">13464</span>.580615<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/board_demo.c board_demo_led_ctl line <span class="m">28</span>, led <span class="m">0</span>, off   // 可以看到这句“off”打印   
	<span class="o">[</span><span class="m">13464</span>.593397<span class="o">]</span> /home/book/source/02_led_drv/01_led_drv_template/leddrv.c led_drv_close line <span class="m">67</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id32">
<h3>课后作业<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<p>  实现读LED状态的功能：涉及APP和驱动。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_045.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_045.png" />
&lt;600px&gt;</p>
</div>
</div>
<div class="section" id="id33">
<h2>具体单板的LED驱动程序<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<p>  我们选用的内核都是4.x版本，操作都是类似的：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	rk3399   linux <span class="m">4</span>.4.154   
	rk3288   linux <span class="m">4</span>.4.154   
	imx6ul   linux <span class="m">4</span>.9.88   
	am3358  linux <span class="m">4</span>.9.168   
</pre></div>
</div>
<p>  录制视频时，我的source insight里总是使用某个版本的内核。这没有关系，驱动程序中调用的内核函数，在这些4.x版本的内核里都是一样的。</p>
<div class="section" id="id34">
<h3>怎么写LED驱动程序？<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h3>
<p>  详细步骤如下：</p>
<p>    ① 看原理图确定引脚，确定引脚输出什么电平才能点亮/熄灭LED</p>
<p>    ② 看主芯片手册，确定寄存器操作方法：哪些寄存器？哪些位？地址是？</p>
<p>    ③ 编写驱动：先写框架，再写硬件操作的代码</p>
<p>      <font color="# dd0000">注意：</font>在芯片手册中确定的寄存器地址被称为<font color="#dd0000">物理地址</font>，在Linux内核中无法直接使用。</p>
<p>      需要使用内核提供的ioremap把物理地址映射为虚拟地址，使用<font color="# dd0000">虚拟地址</font>。</p>
<p>  ioremap函数的使用：</p>
<p>    ① 函数原型：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_046.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_046.png" />
&lt;600px&gt;</p>
<p>      使用时，要包含头文件：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_047.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_047.png" />
&lt;200px&gt;</p>
<p>    ② 它的作用：</p>
<p>      把物理地址phys_addr开始的一段空间(大小为size)，映射为虚拟地址；返回值是该段虚拟地址的首地址。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="n">virt_addr</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">phys_addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>   
</pre></div>
</div>
<p>      实际上，它是按页(4096字节)进行映射的，是整页整页地映射的。</p>
<p>      假设phys_addr = 0x10002，size=4，ioremap的内部实现是：</p>
<p>        a. phys_addr按页取整，得到地址0x10000</p>
<p>        b. size按页取整，得到4096</p>
<p>        c. 把起始地址0x10000，大小为4096的这一块物理地址空间，映射到虚拟地址空间，</p>
<p>          假设得到的虚拟空间起始地址为0xf0010000</p>
<p>        d. 那么phys_addr = 0x10002对应的virt_addr = 0xf0010002</p>
<p>    ③ 不再使用该段虚拟地址时，要iounmap(virt_addr)：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_048.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_048.png" />
&lt;400px&gt;</p>
<p>  volatile的使用：</p>
<p>    ① 编译器很聪明，会帮我们做些优化，比如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="kt">int</span>   <span class="n">a</span><span class="p">;</span>   
	<span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 这句话可以优化掉，不影响a的结果   </span>
	<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   
</pre></div>
</div>
<p>    ② 有时候编译器会自作聪明，比如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">xxxx</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// GPIO寄存器的地址   </span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 点灯，但是这句话被优化掉了   </span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 灭灯   </span>
</pre></div>
</div>
<p>    ③ 对于上面的情况，为了避免编译器自动优化，需要加上volatile，告诉它“这是容易出错的，别乱优化”：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="k">volatile</span>  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">xxxx</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// GPIO寄存器的地址   </span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 点灯，这句话不会被优化掉   </span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 灭灯   </span>
</pre></div>
</div>
</div>
<div class="section" id="am335xled">
<h3>AM335X的LED驱动程序<a class="headerlink" href="#am335xled" title="永久链接至标题">¶</a></h3>
<div class="section" id="id35">
<h4>原理图<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h4>
<p>  100ask_AM335X开发板结构为：底板+核心板，其中一个LED原理图如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_049.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_049.png" />
&lt;1200px&gt;</p>
<p>  它使用GPIO1_16这个引脚，当它输出低电平时，LED被点亮；当它输出高电平时，LED被熄灭。</p>
</div>
<div class="section" id="id36">
<h4>所涉及的寄存器操作<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h4>
<p>  a. 使能GPIO1</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_050.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_050.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* set PRCM to enalbe GPIO1   </span>
<span class="cm">	 * set CM_PER_GPIO1_CLKCTRL (0x44E00000 + 0xAC)   </span>
<span class="cm">	 * val: (1&lt;&lt;18) | 0x2   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  b. 设置GPIO1_16的功能，让它工作于GPIO模式</p>
<p>    根据原理图可以找到GPIO1_16这个引脚接到AM3358的R13引脚，根据下图知道pin name为GPMC_A0，并且知道要设置这个引脚为Mode 7。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_051.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_051.png" />
&lt;600px&gt;</p>
<p>    在芯片手册中搜“conf_gpmc_a0”，可得：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_052.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_052.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* set Control Module to set GPIO1_16 (R13) used as GPIO   </span>
<span class="cm">	 * conf_gpmc_a0 as mode 7   </span>
<span class="cm">	 * addr : 0x44E10000 + 0x840   </span>
<span class="cm">	 * val  : 7   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  c. 设置GPIO1_16的方向，让它作为输出引脚</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_053.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_053.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* set GPIO1&#39;s registers , to set GPIO1_16&#39;S dir (output)   </span>
<span class="cm">	 * GPIO_OE   </span>
<span class="cm">	 * addr : 0x4804C000 + 0x134   </span>
<span class="cm">	 * clear bit 16   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  d. 设置GPIO1_16的数据，让它输出高电平</p>
<p>    AM335X芯片支持set-and-clear protocol，设置GPIO_SETDATAOUT的bit 16为1即可让引脚输出1：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_054.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_054.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* set GPIO1_16&#39;s registers , to output 1   </span>
<span class="cm">	 * GPIO_SETDATAOUT   </span>
<span class="cm">	 * addr : 0x4804C000 + 0x194   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  e. 清除GPIO1_16的数据，让它输出低电平</p>
<p>    AM335X芯片支持set-and-clear protocol，设置GPIO_CLEARDATAOUT的bit 16为1即可让引脚输出0：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_055.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_055.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* set GPIO1_16&#39;s registers , to output 0   </span>
<span class="cm">	 * GPIO_CLEARDATAOUT   </span>
<span class="cm">	 * addr : 0x4804C000 + 0x190   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
</div>
<div class="section" id="id37">
<h4>写程序<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h4>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>2_led_drv<span class="se">\ </span>  
	  	02_led_drv_for_boards<span class="se">\a</span>m335x_src_bin   
</pre></div>
</div>
<p>  硬件相关的文件是board_am335x.c，其他文件跟LED框架驱动程序完全一样。</p>
<p>  它首先构造了一个led_operations结构体，用来表示LED的硬件操作：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">100</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="n">board_demo_led_opr</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">101</span>    <span class="p">.</span><span class="n">num</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
	<span class="mi">102</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_demo_led_init</span><span class="p">,</span>   
	<span class="mi">103</span>    <span class="p">.</span><span class="n">ctl</span>  <span class="o">=</span> <span class="n">board_demo_led_ctl</span><span class="p">,</span>   
	<span class="mi">104</span> <span class="p">};</span>   
	<span class="mi">105</span>   
</pre></div>
</div>
<p>  led_operations结构体中有init函数指针，它指向board_demo_led_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。</p>
<p>  值得关注的是第33～37行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	19 # include &quot;led_opr.h&quot;   
	20   
	21 static volatile unsigned int *CM_PER_GPIO1_CLKCTRL;   
	22 static volatile unsigned int *conf_gpmc_a0;   
	23 static volatile unsigned int *GPIO1_OE;   
	24 static volatile unsigned int *GPIO1_CLEARDATAOUT;   
	25 static volatile unsigned int *GPIO1_SETDATAOUT;   
	26   
	27 static int board_demo_led_init (int which) /* 初始化LED, which-哪个LED */   
	28 {   
	29    if (which == 0)   
	30    {   
	31       if (!CM_PER_GPIO1_CLKCTRL)   
	32       {   
	33          CM_PER_GPIO1_CLKCTRL = ioremap(0x44E00000 + 0xAC, 4);   
	34          conf_gpmc_a0 = ioremap(0x44E10000 + 0x840, 4);   
	35          GPIO1_OE = ioremap(0x4804C000 + 0x134, 4);   
	36          GPIO1_CLEARDATAOUT = ioremap(0x4804C000 + 0x190, 4);   
	37          GPIO1_SETDATAOUT = ioremap(0x4804C000 + 0x194, 4);   
	38       }   
	39   
	40       //printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   
	41       /* a. 使能GPIO1   
	42        * set PRCM to enalbe GPIO1   
	43        * set CM_PER_GPIO1_CLKCTRL (0x44E00000 + 0xAC)   
	44        * val: (1&lt;&lt;18) | 0x2   
	45        */   
	46       *CM_PER_GPIO1_CLKCTRL = (1&lt;&lt;18) | 0x2;   
	47   
	48       /* b. 设置GPIO1_16的功能，让它工作于GPIO模式   
	49        * set Control Module to set GPIO1_16 (R13) used as GPIO   
	50        * conf_gpmc_ad0 as mode 7   
	51        * addr : 0x44E10000 + 0x800   
	52        * val  : 7   
	53        */   
	54       *conf_gpmc_a0 = 7;   
	55   
	56       /* c. 设置GPIO1_16的方向，让它作为输出引脚   
	57        * set GPIO1&#39;s registers , to set GPIO1_16&#39;S dir (output)   
	58        * GPIO_OE   
	59        * addr : 0x4804C000 + 0x134   
	60        * clear bit 16   
	61        */   
	62   
	63       *GPIO1_OE &amp;= ~(1&lt;&lt;16);   
	64    }   
	65   
	66    return 0;   
	67 }   
	68   
   
</pre></div>
</div>
<p>  led_operations结构体中有ctl函数指针，它指向board_demo_led_ctl函数，在里面将会根据参数设置LED引脚的输出电平：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">69</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">char</span> <span class="n">status</span><span class="p">)</span> <span class="cm">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span>   
	<span class="mi">70</span> <span class="p">{</span>   
	<span class="mi">71</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);   </span>
	<span class="mi">72</span>   
	<span class="mi">73</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">74</span>    <span class="p">{</span>   
	<span class="mi">75</span>       <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="cm">/* on: output 0 */</span>   
	<span class="mi">76</span>       <span class="p">{</span>   
	<span class="mi">77</span>          <span class="cm">/* e. 清除GPIO1_16的数据，让它输出低电平   </span>
<span class="cm">	78           * AM335X芯片支持set-and-clear protocol，设置GPIO_CLEARDATAOUT的bit 16为1即可让引脚输出0：   </span>
<span class="cm">	79           * set GPIO1_16&#39;s registers , to output 0   </span>
<span class="cm">	80           * GPIO_CLEARDATAOUT   </span>
<span class="cm">	81           * addr : 0x4804C000 + 0x190   </span>
<span class="cm">	82           */</span>   
	<span class="mi">83</span>          <span class="o">*</span><span class="n">GPIO1_CLEARDATAOUT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">);</span>   
	<span class="mi">84</span>       <span class="p">}</span>   
	<span class="mi">85</span>       <span class="k">else</span>   
	<span class="mi">86</span>       <span class="p">{</span>   
	<span class="mi">87</span>          <span class="cm">/* d. 设置GPIO1_16的数据，让它输出高电平   </span>
<span class="cm">	88           * AM335X芯片支持set-and-clear protocol，设置GPIO_SETDATAOUT的bit 16为1即可让引脚输出1：   </span>
<span class="cm">	89           * set GPIO1_16&#39;s registers , to output 1   </span>
<span class="cm">	90           * GPIO_SETDATAOUT   </span>
<span class="cm">	91           * addr : 0x4804C000 + 0x194   </span>
<span class="cm">	92           */</span>   
	<span class="mi">93</span>          <span class="o">*</span><span class="n">GPIO1_SETDATAOUT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">);</span>   
	<span class="mi">94</span>       <span class="p">}</span>   
	<span class="mi">95</span>    <span class="p">}</span>   
	<span class="mi">96</span>   
	<span class="mi">97</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">98</span> <span class="p">}</span>   
	<span class="mi">99</span>   
</pre></div>
</div>
<p>  下面的get_board_led_opr函数供上层调用，给上层提供led_operations结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">106</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="o">*</span><span class="nf">get_board_led_opr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mi">107</span> <span class="p">{</span>   
	<span class="mi">108</span>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">;</span>   
	<span class="mi">109</span> <span class="p">}</span>   
	<span class="mi">110</span>   
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h4>配置内核去掉原有LED驱动<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h4>
<p>  不需要重新配置内核，只需要在开发板上执行以下3条命令关闭内核对LED的使用即可：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo none &gt; /sys/class/leds/am335x:green:cpu0/trigger   </span>
	<span class="c1">#  echo none &gt; /sys/class/leds/am335x:green:mmc0/trigger   </span>
	<span class="c1">#  echo none &gt; /sys/class/leds/am335x:green:nand/trigger   </span>
</pre></div>
</div>
<p>  然后就可以去安装驱动程序，执行测试程序了，操作过程跟LED框架驱动程序的测试是一样的。</p>
</div>
<div class="section" id="id39">
<h4>课后作业<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h4>
<p>  a. 在board_am335x.c里有ioremap，什么时候执行iounmap？请完善程序</p>
<p>  b. 视频里我们只实现了点一个LED，请修改代码实现操作4个LED</p>
</div>
</div>
<div class="section" id="rk3288rk3399led">
<h3>RK3288和RK3399的LED驱动程序<a class="headerlink" href="#rk3288rk3399led" title="永久链接至标题">¶</a></h3>
<div class="section" id="id40">
<h4>原理图<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h4>
<div class="section" id="fireflye-rk3288led">
<h5>fireflye RK3288的LED原理图<a class="headerlink" href="#fireflye-rk3288led" title="永久链接至标题">¶</a></h5>
<p>  RK3288开发板上有2个LED，原理图如下，其中的WORK_LED使用引脚GPIO8_A1：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_056.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_056.png" />
&lt;800px&gt;</p>
<p>  这些LED引脚输出低电平时，LED被点亮；输出高电平时，LED被熄灭。</p>
</div>
<div class="section" id="firefly-rk3399led">
<h5>firefly RK3399的LED原理图<a class="headerlink" href="#firefly-rk3399led" title="永久链接至标题">¶</a></h5>
<p>  RK3399开发板上有3个LED，原理图如下，其中的WORK_LED使用引脚GPIO2_D3：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_057.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_057.png" />
&lt;1200px&gt;</p>
<p>  这些LED引脚输出低电平时，LED被点亮；输出高电平时，LED被熄灭。</p>
</div>
</div>
<div class="section" id="id41">
<h4>所涉及的寄存器操作<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h4>
<p>  截图便于对比，后面有文字便于复制：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_058.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_058.png" />
&lt;800px&gt;</p>
<div class="section" id="rk3288gpio8-a1">
<h5>RK3288的GPIO8_A1引脚<a class="headerlink" href="#rk3288gpio8-a1" title="永久链接至标题">¶</a></h5>
<p>  a. 使能GPIO8</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_059.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_059.png" />
&lt;600px&gt;</p>
<p>  设置CRU_CLKGATE14_CON的b[8]为0使能GPIO8，要修改b[8]的前提是把b[24]设置为1。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* rk3288 GPIO8_A1 */</span>   
	<span class="cm">/* a. 使能GPIO8   </span>
<span class="cm">	 * set CRU to enable GPIO8   </span>
<span class="cm">	 * CRU_CLKGATE14_CON 0xFF760000 + 0x198   </span>
<span class="cm">	 * (1&lt;&lt;(8+16)) | (0&lt;&lt;8)   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  b. 设置GPIO8_A1用于GPIO</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_060.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_060.png" />
&lt;600px&gt;</p>
<p>  设置GRF_GPIO8A_IOMUX的b[3:2]为0b00把GPIO8_A1用作GPIO，要修改b[3:2]的前提是把b[19:18]设置为0b11。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	/* b. 设置GPIO8_A1用于GPIO   
	 * set PMU/GRF to configure GPIO8_A1 as GPIO   
	 * GRF_GPIO8A_IOMUX 0xFF770000 + 0x0080   
	 * bit[3:2] = 0b00   
	 * (3&lt;&lt;(2+16)) | (0&lt;&lt;2)   
	 */   
```	

&amp;emsp;&amp;emsp;c. 设置GPIO8_A1作为output引脚

![](https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_061.png) 
&lt;600px&gt;

&amp;emsp;&amp;emsp;设置GPIO_SWPORTA_DDR 寄存器b[1]为1，把GPIO8_A1设置为输出引脚。

&amp;emsp;&amp;emsp;&lt;font color=&quot;# dd0000&quot;&gt;注意：&lt;/font&gt;

&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;GPIO_A0~A7 对应bit0~bit7；GPIO_B0~B7 对应bit8~bit15；

&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;GPIO_C0~C7 对应bit16~bit23；GPIO_D0~D7 对应bit24~bit31

``` C
/* c. 设置GPIO8_A1作为output引脚   
 * set GPIO_SWPORTA_DDR to configure GPIO8_A1 as output   
 * GPIO_SWPORTA_DDR 0xFF7F0000 + 0x0004   
 * bit[1] = 0b1   
 */   
</pre></div>
</div>
<p>  d. 设置GPIO8_A1输出高电平</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_062.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_062.png" />
&lt;600px&gt;</p>
<p>  设置GPIO_SWPORTA_DR 寄存器b[1]为1，让GPIO8_A1输出高电平。</p>
<p>  <font color="# dd0000">注意：</font></p>
<p>    GPIO_A0~A7 对应bit0~bit7；GPIO_B0~B7 对应bit8~bit15；</p>
<p>    GPIO_C0~C7 对应bit16~bit23；GPIO_D0~D7 对应bit24~bit31</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* d. 设置GPIO8_A1输出高电平   </span>
<span class="cm">	 * set GPIO_SWPORTA_DR to configure GPIO8_A1 output 1   </span>
<span class="cm">	 * GPIO_SWPORTA_DR 0xFF7F0000 + 0x0000   </span>
<span class="cm">	 * bit[1] = 0b1   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  e. 设置GPIO8_A1输出低电平</p>
<p>    同样是设置GPIO_SWPORTA_DR 寄存器，把b[1]设为0，让GPIO8_A1输出低电平。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* e. 设置GPIO8_A1输出低电平   </span>
<span class="cm">	 * set GPIO_SWPORTA_DR to configure GPIO8_A1 output 0   </span>
<span class="cm">	 * GPIO_SWPORTA_DR 0xFF7F0000 + 0x0000   </span>
<span class="cm">	 * bit[1] = 0b0   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
</div>
<div class="section" id="rk3399gpio2-d3">
<h5>RK3399的GPIO2_D3引脚<a class="headerlink" href="#rk3399gpio2-d3" title="永久链接至标题">¶</a></h5>
<p>  a. 使能GPIO2</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_063.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_063.png" />
&lt;600px&gt;</p>
<p>  设置CRU_CLKGATE_CON31的b[3]为0使能GPIO2，要修改b[3]的前提是把b[19]设置为1。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* rk3399 GPIO2_D3 */</span>   
	<span class="cm">/* a. 使能GPIO2   </span>
<span class="cm">	 * set CRU to enable GPIO2   </span>
<span class="cm">	 * CRU_CLKGATE_CON31 0xFF760000 + 0x037c   </span>
<span class="cm">	 * (1&lt;&lt;(3+16)) | (0&lt;&lt;3)   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  b. 设置GPIO2_D3用于GPIO</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_064.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_064.png" />
&lt;600px&gt;</p>
<p>  设置GRF_GPIO2D_IOMUX的b[7:6]为0b00把GPIO2_D3用作GPIO，要修改b[7:6]的前提是把b[23:22]设置为0b11。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* b. 设置GPIO2_D3用于GPIO   </span>
<span class="cm">	 * set PMU/GRF to configure GPIO2_D3 as GPIO   </span>
<span class="cm">	 * GRF_GPIO2D_IOMUX 0xFF770000 + 0x0e00c   </span>
<span class="cm">	 * bit[7:6] = 0b00   </span>
<span class="cm">	 * (3&lt;&lt;(6+16)) | (0&lt;&lt;6)   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  c. 设置GPIO2_D3作为output引脚</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_065.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_065.png" />
&lt;600px&gt;</p>
<p>  设置GPIO_SWPORTA_DDR 寄存器b[27]为1，把GPIO2_D3设置为输出引脚。</p>
<p>  <font color="# dd0000">注意：</font></p>
<p>    GPIO_A0~A7 对应bit0~bit7；GPIO_B0~B7 对应bit8~bit15；</p>
<p>    GPIO_C0~C7 对应bit16~bit23；GPIO_D0~D7 对应bit24~bit31</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* c. 设置GPIO2_D3作为output引脚   </span>
<span class="cm">	 * set GPIO_SWPORTA_DDR to configure GPIO2_D3 as output   </span>
<span class="cm">	 * GPIO_SWPORTA_DDR 0xFF780000 + 0x0004   </span>
<span class="cm">	 * bit[27] = 0b1   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  d. 设置GPIO2_D3输出高电平</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_066.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_066.png" />
&lt;600px&gt;</p>
<p>  设置GPIO_SWPORTA_DR 寄存器b[27]为1，让GPIO2_D3输出高电平。</p>
<p>  <font color="# dd0000">注意：</font></p>
<p>    GPIO_A0~A7 对应bit0~bit7；GPIO_B0~B7 对应bit8~bit15；</p>
<p>    GPIO_C0~C7 对应bit16~bit23；GPIO_D0~D7 对应bit24~bit31</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* d. 设置GPIO2_D3输出高电平   </span>
<span class="cm">	 * set GPIO_SWPORTA_DR to configure GPIO2_D3 output 1   </span>
<span class="cm">	 * GPIO_SWPORTA_DR 0xFF780000 + 0x0000   </span>
<span class="cm">	 * bit[27] = 0b1   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  e. 设置GPIO2_D3输出低电平</p>
<p>    同样是设置GPIO_SWPORTA_DR 寄存器，把b[27]设为0，让GPIO2_D3输出低电平。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* e. 设置GPIO2_D3输出低电平   </span>
<span class="cm">	 * set GPIO_SWPORTA_DR to configure GPIO2_D3 output 0   </span>
<span class="cm">	 * GPIO_SWPORTA_DR 0xFF780000 + 0x0000   </span>
<span class="cm">	 * bit[27] = 0b0   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id42">
<h4>写程序<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h4>
<div class="section" id="rk3288">
<h5>RK3288<a class="headerlink" href="#rk3288" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>2_led_drv<span class="se">\ </span>  
	  	02_led_drv_for_boards<span class="se">\r</span>k3288_src_bin   
</pre></div>
</div>
<p>  硬件相关的文件是board_rk3288.c，其他文件跟LED框架驱动程序完全一样。</p>
<p>  它首先构造了一个led_operations结构体，用来表示LED的硬件操作：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">91</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="n">board_demo_led_opr</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">92</span>     <span class="p">.</span><span class="n">num</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
	<span class="mi">93</span>     <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_demo_led_init</span><span class="p">,</span>   
	<span class="mi">94</span>     <span class="p">.</span><span class="n">ctl</span>  <span class="o">=</span> <span class="n">board_demo_led_ctl</span><span class="p">,</span>   
	<span class="mi">95</span> <span class="p">};</span>   
	<span class="mi">96</span>   
</pre></div>
</div>
<p>  led_operations结构体中有init函数指针，它指向board_demo_led_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。</p>
<p>  值得关注的是第32～35行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">20</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">CRU_CLKGATE14_CON</span><span class="p">;</span>   
	<span class="mi">21</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GRF_GPIO8A_IOMUX</span> <span class="p">;</span>   
	<span class="mi">22</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO8_SWPORTA_DDR</span><span class="p">;</span>   
	<span class="mi">23</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO8_SWPORTA_DR</span> <span class="p">;</span>   
	<span class="mi">24</span>   
	<span class="mi">25</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化LED, which-哪个LED */</span>      
	<span class="mi">26</span> <span class="p">{</span>   
	<span class="mi">27</span>     <span class="c1">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   </span>
	<span class="mi">28</span>     <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">29</span>     <span class="p">{</span>   
	<span class="mi">30</span>           <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CRU_CLKGATE14_CON</span><span class="p">)</span>   
	<span class="mi">31</span>           <span class="p">{</span>   
	<span class="mi">32</span>                 <span class="n">CRU_CLKGATE14_CON</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF760000</span> <span class="o">+</span> <span class="mh">0x0198</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">33</span>                 <span class="n">GRF_GPIO8A_IOMUX</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF770000</span> <span class="o">+</span> <span class="mh">0x0080</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">34</span>                 <span class="n">GPIO8_SWPORTA_DDR</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF7F0000</span> <span class="o">+</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">35</span>                 <span class="n">GPIO8_SWPORTA_DR</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF7F0000</span> <span class="o">+</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">36</span>           <span class="p">}</span>   
	<span class="mi">37</span>   
	<span class="mi">38</span>           <span class="cm">/* rk3288 GPIO8_A1 */</span>   
	<span class="mi">39</span>           <span class="cm">/* a. 使能GPIO8   </span>
<span class="cm">	40            * set CRU to enable GPIO8   </span>
<span class="cm">	41            * CRU_CLKGATE14_CON 0xFF760000 + 0x198   </span>
<span class="cm">	42            * (1&lt;&lt;(8+16)) | (0&lt;&lt;8)   </span>
<span class="cm">	43            */</span>   
	<span class="mi">44</span>           <span class="o">*</span><span class="n">CRU_CLKGATE14_CON</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>   
	<span class="mi">45</span>   
	<span class="mi">46</span>           <span class="cm">/* b. 设置GPIO8_A1用于GPIO   </span>
<span class="cm">	47            * set PMU/GRF to configure GPIO8_A1 as GPIO   </span>
<span class="cm">	48            * GRF_GPIO8A_IOMUX 0xFF770000 + 0x0080   </span>
<span class="cm">	49            * bit[3:2] = 0b00   </span>
<span class="cm">	50            * (3&lt;&lt;(2+16)) | (0&lt;&lt;2)   </span>
<span class="cm">	51            */</span>   
	<span class="mi">52</span>           <span class="o">*</span><span class="n">GRF_GPIO8A_IOMUX</span> <span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>   
	<span class="mi">53</span>   
	<span class="mi">54</span>           <span class="cm">/* c. 设置GPIO8_A1作为output引脚   </span>
<span class="cm">	55            * set GPIO_SWPORTA_DDR to configure GPIO8_A1 as output   </span>
<span class="cm">	56            * GPIO_SWPORTA_DDR 0xFF7F0000 + 0x0004   </span>
<span class="cm">	57            * bit[1] = 0b1   </span>
<span class="cm">	58            */</span>   
	<span class="mi">59</span>           <span class="o">*</span><span class="n">GPIO8_SWPORTA_DDR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span>   
	<span class="mi">60</span>     <span class="p">}</span>   
	<span class="mi">61</span>           <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">62</span> <span class="p">}</span>   
	<span class="mi">63</span>   
</pre></div>
</div>
<p>  led_operations结构体中有ctl函数指针，它指向board_demo_led_ctl函数，在里面将会根据参数设置LED引脚的输出电平：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">64</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">char</span> <span class="n">status</span><span class="p">)</span> <span class="cm">/* 控制LED, which-哪个LED, status:1-亮, 0-灭*/</span>   
	<span class="mi">65</span> <span class="p">{</span>   
	<span class="mi">66</span>     <span class="c1">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);   </span>
	<span class="mi">67</span>     <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">68</span>     <span class="p">{</span>   
	<span class="mi">69</span>           <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="cm">/* on: output 0 */</span>   
	<span class="mi">70</span>           <span class="p">{</span>   
	<span class="mi">71</span>                 <span class="cm">/* e. 设置GPIO8_A1输出低电平   </span>
<span class="cm">	72                  * set GPIO_SWPORTA_DR to configure GPIO8_A1 output 0   </span>
<span class="cm">	73                  * GPIO_SWPORTA_DR 0xFF7F0000 + 0x0000   </span>
<span class="cm">	74                  * bit[1] = 0b0   </span>
<span class="cm">	75                  */</span>   
	<span class="mi">76</span>                 <span class="o">*</span><span class="n">GPIO8_SWPORTA_DR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span>   
	<span class="mi">77</span>           <span class="p">}</span>   
	<span class="mi">78</span>           <span class="k">else</span> <span class="cm">/* off: output 1 */</span>   
	<span class="mi">79</span>           <span class="p">{</span>   
	<span class="mi">80</span>                 <span class="cm">/* d. 设置GPIO8_A1输出高电平   </span>
<span class="cm">	81                  * set GPIO_SWPORTA_DR to configure GPIO8_A1 output 1   </span>
<span class="cm">	82                  * GPIO_SWPORTA_DR 0xFF7F0000 + 0x0000   </span>
<span class="cm">	83                  * bit[1] = 0b1   </span>
<span class="cm">	84                  */</span>   
	<span class="mi">85</span>                 <span class="o">*</span><span class="n">GPIO8_SWPORTA_DR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span>   
	<span class="mi">86</span>           <span class="p">}</span>   
	<span class="mi">87</span>     <span class="p">}</span>   
	<span class="mi">88</span>     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">89</span> <span class="p">}</span>   
	<span class="mi">90</span>   
</pre></div>
</div>
<p>  下面的get_board_led_opr函数供上层调用，给上层提供led_operations结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">97</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="o">*</span><span class="nf">get_board_led_opr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mi">98</span> <span class="p">{</span>   
	<span class="mi">99</span>     <span class="k">return</span> <span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">;</span>   
	<span class="mi">100</span> <span class="p">}</span>   
	<span class="mi">101</span>   
</pre></div>
</div>
</div>
<div class="section" id="rk3399">
<h5>RK3399<a class="headerlink" href="#rk3399" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>2_led_drv<span class="se">\ </span>  
	  	02_led_drv_for_boards<span class="se">\r</span>k3399_src_bin   
</pre></div>
</div>
<p>  硬件相关的文件是board_rk3399.c，其他文件跟LED框架驱动程序完全一样。</p>
<p>  它首先构造了一个led_operations结构体，用来表示LED的硬件操作：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="m">91</span> static struct led_operations <span class="nv">board_demo_led_opr</span> <span class="o">=</span> <span class="o">{</span>   
	<span class="m">92</span>    .num  <span class="o">=</span> <span class="m">1</span>,   
	<span class="m">93</span>    .init <span class="o">=</span> board_demo_led_init,   
	<span class="m">94</span>    .ctl  <span class="o">=</span> board_demo_led_ctl,   
	<span class="m">95</span> <span class="o">}</span><span class="p">;</span>   
	<span class="m">96</span>   
</pre></div>
</div>
<p>  led_operations结构体中有init函数指针，它指向board_demo_led_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。</p>
<p>  值得关注的是第32～35行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="m">20</span> static volatile unsigned int *CRU_CLKGATE_CON31<span class="p">;</span>   
	<span class="m">21</span> static volatile unsigned int *GRF_GPIO2D_IOMUX <span class="p">;</span>   
	<span class="m">22</span> static volatile unsigned int *GPIO2_SWPORTA_DDR<span class="p">;</span>   
	<span class="m">23</span> static volatile unsigned int *GPIO2_SWPORTA_DR <span class="p">;</span>   
	<span class="m">24</span>   
	<span class="m">25</span> static int board_demo_led_init <span class="o">(</span>int which<span class="o">)</span> /* 初始化LED, which-哪个LED */      
	<span class="m">26</span> <span class="o">{</span>   
	<span class="m">27</span>    //printk<span class="o">(</span><span class="s2">&quot;%s %s line %d, led %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which<span class="o">)</span><span class="p">;</span>   
	<span class="m">28</span>    <span class="k">if</span> <span class="o">(</span><span class="nv">which</span> <span class="o">==</span> <span class="m">0</span><span class="o">)</span>   
	<span class="m">29</span>    <span class="o">{</span>   
	<span class="m">30</span>       <span class="k">if</span> <span class="o">(</span>!CRU_CLKGATE_CON31<span class="o">)</span>   
	<span class="m">31</span>       <span class="o">{</span>   
	<span class="m">32</span>          <span class="nv">CRU_CLKGATE_CON31</span> <span class="o">=</span> ioremap<span class="o">(</span>0xFF760000 + 0x037c, <span class="m">4</span><span class="o">)</span><span class="p">;</span>   
	<span class="m">33</span>          <span class="nv">GRF_GPIO2D_IOMUX</span>  <span class="o">=</span> ioremap<span class="o">(</span>0xFF770000 + 0x0e00c, <span class="m">4</span><span class="o">)</span><span class="p">;</span>   
	<span class="m">34</span>          <span class="nv">GPIO2_SWPORTA_DDR</span> <span class="o">=</span> ioremap<span class="o">(</span>0xFF780000 + 0x0004, <span class="m">4</span><span class="o">)</span><span class="p">;</span>   
	<span class="m">35</span>          <span class="nv">GPIO2_SWPORTA_DR</span>  <span class="o">=</span> ioremap<span class="o">(</span>0xFF780000 + 0x0000, <span class="m">4</span><span class="o">)</span><span class="p">;</span>   
	<span class="m">36</span>       <span class="o">}</span>   
	<span class="m">37</span>   
	<span class="m">38</span>       /* rk3399 GPIO2_D3 */   
	<span class="m">39</span>       /* a. 使能GPIO2   
	<span class="m">40</span>        * <span class="nb">set</span> CRU to <span class="nb">enable</span> GPIO2   
	<span class="m">41</span>        * CRU_CLKGATE_CON31 0xFF760000 + 0x037c   
	<span class="m">42</span>        * <span class="o">(</span><span class="m">1</span>&lt;&lt;<span class="o">(</span><span class="m">3</span>+16<span class="o">))</span> <span class="p">|</span> <span class="o">(</span><span class="m">0</span><span class="s">&lt;&lt;3)   </span>
<span class="s">	43</span>        */   
	<span class="m">44</span>       *CRU_CLKGATE_CON31 <span class="o">=</span> <span class="o">(</span><span class="m">1</span>&lt;&lt;<span class="o">(</span><span class="m">3</span>+16<span class="o">))</span> <span class="p">|</span> <span class="o">(</span><span class="m">0</span><span class="s">&lt;&lt;3);   </span>
<span class="s">	45   </span>
<span class="s">	46       /* b. 设置GPIO2_D3</span>用于GPIO   
	<span class="m">47</span>        * <span class="nb">set</span> PMU/GRF to configure GPIO2_D3 as GPIO   
	<span class="m">48</span>        * GRF_GPIO2D_IOMUX 0xFF770000 + 0x0e00c   
	<span class="m">49</span>        * bit<span class="o">[</span><span class="m">7</span>:6<span class="o">]</span> <span class="o">=</span> 0b00   
	<span class="m">50</span>        * <span class="o">(</span><span class="m">3</span>&lt;&lt;<span class="o">(</span><span class="m">6</span>+16<span class="o">))</span> <span class="p">|</span> <span class="o">(</span><span class="m">0</span><span class="s">&lt;&lt;6)   </span>
<span class="s">	51        */   </span>
<span class="s">	52       *GRF_GPIO2D_IOMUX = (3&lt;&lt;(6</span>+16<span class="o">))</span> <span class="p">|</span> <span class="o">(</span><span class="m">0</span><span class="s">&lt;&lt;6);   </span>
<span class="s">	53   </span>
<span class="s">	54       /* c. 设置GPIO2_D3作为output引脚   </span>
<span class="s">	55        * set GPIO_SWPORTA_DDR to configure GPIO2_D3 as output   </span>
<span class="s">	56</span>        * GPIO_SWPORTA_DDR 0xFF780000 + 0x0004   
	<span class="m">57</span>        * bit<span class="o">[</span><span class="m">27</span><span class="o">]</span> <span class="o">=</span> 0b1   
	<span class="m">58</span>        */   
	<span class="m">59</span>       *GPIO2_SWPORTA_DDR <span class="p">|</span><span class="o">=</span> <span class="o">(</span><span class="m">1</span><span class="s">&lt;&lt;27);   </span>
<span class="s">	60    }   </span>
<span class="s">	61    return 0;   </span>
<span class="s">	62</span> <span class="o">}</span>   
	<span class="m">63</span>   
</pre></div>
</div>
<p>  led_operations结构体中有ctl函数指针，它指向board_demo_led_ctl函数，在里面将会根据参数设置LED引脚的输出电平：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="m">64</span> static int board_demo_led_ctl <span class="o">(</span>int which, char status<span class="o">)</span> /* 控制LED, which-哪个LED, status:1-亮, <span class="m">0</span>-灭*/   
	<span class="m">65</span> <span class="o">{</span>   
	<span class="m">66</span>    //printk<span class="o">(</span><span class="s2">&quot;%s %s line %d, led %d, %s\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which, status ? <span class="s2">&quot;on&quot;</span> : <span class="s2">&quot;off&quot;</span><span class="o">)</span><span class="p">;</span>   
	<span class="m">67</span>    <span class="k">if</span> <span class="o">(</span><span class="nv">which</span> <span class="o">==</span> <span class="m">0</span><span class="o">)</span>   
	<span class="m">68</span>    <span class="o">{</span>   
	<span class="m">69</span>       <span class="k">if</span> <span class="o">(</span>status<span class="o">)</span> /* on: output <span class="m">1</span> */   
	<span class="m">70</span>       <span class="o">{</span>   
	<span class="m">71</span>          /* d. 设置GPIO2_D3输出高电平   
	<span class="m">72</span>           * <span class="nb">set</span> GPIO_SWPORTA_DR to configure GPIO2_D3 output <span class="m">1</span>   
	<span class="m">73</span>           * GPIO_SWPORTA_DR 0xFF780000 + 0x0000   
	<span class="m">74</span>           * bit<span class="o">[</span><span class="m">27</span><span class="o">]</span> <span class="o">=</span> 0b1   
	<span class="m">75</span>           */   
	<span class="m">76</span>          *GPIO2_SWPORTA_DR <span class="p">|</span><span class="o">=</span> <span class="o">(</span><span class="m">1</span><span class="s">&lt;&lt;27);   </span>
<span class="s">	77       }   </span>
<span class="s">	78       else /* off : output 0 */   </span>
<span class="s">	79       {   </span>
<span class="s">	80          /* e. 设置GPIO2_D3输出低电平   </span>
<span class="s">	81           * set GPIO_SWPORTA_DR to configure GPIO2_D3 output 0   </span>
<span class="s">	82           * GPIO_SWPORTA_DR 0xFF780000 + 0x0000   </span>
<span class="s">	83           * bit[27</span><span class="o">]</span> <span class="o">=</span> 0b0   
	<span class="m">84</span>           */   
	<span class="m">85</span>          *GPIO2_SWPORTA_DR <span class="p">&amp;</span><span class="o">=</span> ~<span class="o">(</span><span class="m">1</span>&lt;&lt;<span class="m">27</span><span class="o">)</span><span class="p">;</span>   
	<span class="m">86</span>       <span class="o">}</span>   
	<span class="m">87</span>    <span class="o">}</span>   
	<span class="m">88</span>    <span class="k">return</span> <span class="m">0</span><span class="p">;</span>   
	<span class="m">89</span> <span class="o">}</span>   
	<span class="m">90</span>   
</pre></div>
</div>
<p>  下面的get_board_led_opr函数供上层调用，给上层提供led_operations结构体：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="m">97</span> struct led_operations *get_board_led_opr<span class="o">(</span>void<span class="o">)</span>   
	<span class="m">98</span> <span class="o">{</span>   
	<span class="m">99</span>    <span class="k">return</span> <span class="p">&amp;</span>board_demo_led_opr<span class="p">;</span>   
	<span class="m">100</span> <span class="o">}</span>   
	<span class="m">101</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id43">
<h4>上机实验<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h4>
<p>  首先设置工具链，然后修改驱动程序Makefile指定内核源码路径，就可以编译驱动程序和测试程序了。</p>
<p>  启动开发板，挂载NFS文件系统，这样就可以访问到Ubuntu中的文件。</p>
<p>  最后，就可以在开发板上进行下列测试。</p>
<div class="section" id="id44">
<h5>RK3288<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h5>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  insmod  100ask_led.ko   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  on   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  off   </span>
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h5>RK3399<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h5>
<p>  要先禁止内核中原来的LED驱动，把“heatbeat”功能关闭，执行以下命令即可：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo none &gt; /sys/class/leds/firefly\:yellow\:heartbeat/trigger   </span>
	<span class="c1">#  echo none &gt; /sys/class/leds/firefly\:yellow\:user/trigger   </span>
	<span class="c1">#  echo none &gt; /sys/class/leds/firefly\:red\:power/trigger   </span>
</pre></div>
</div>
<p>  这样就可以使用我们的驱动程序做实验了：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  insmod  100ask_led.ko   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  on   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  off   </span>
</pre></div>
</div>
<p>  如果想恢复原来的心跳功能，可以执行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo heartbeat &gt; /sys/class/leds/firefly\:yellow\:heartbeat/trigger   </span>
	<span class="c1">#  echo heartbeat &gt; /sys/class/leds/firefly\:yellow\:user/trigger   </span>
	<span class="c1">#  echo heartbeat &gt; /sys/class/leds/firefly\:red\:power/trigger   </span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id46">
<h4>课后作业<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h4>
<p>  a. 在驱动里有ioremap，什么时候执行iounmap？请完善程序</p>
<p>  b. 视频里我们只实现了点一个LED，请修改代码实现操作所有LED</p>
</div>
</div>
<div class="section" id="imx6ullled">
<h3>野火/正点原子IMX6ULL的LED驱动程序<a class="headerlink" href="#imx6ullled" title="永久链接至标题">¶</a></h3>
<p>  野火、正点原子用的内核版本是<font color="# dd0000">4.1.15</font>，</p>
<p>  我们用的内核版本是 <font color="# dd0000">linux 4.9.88</font>，</p>
<p>  都是4.x版本，在学习上<font color="# dd0000">没有任何差别</font>。</p>
<p>  你拿到板子后，可以使用他们出厂的系统，</p>
<p>  也可以根据我们提供的高级用户手册更改为我们的系统。</p>
<div class="section" id="id47">
<h4>原理图<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h4>
<div class="section" id="fire-imx6ull-pro">
<h5>野火fire_imx6ull-pro开发板<a class="headerlink" href="#fire-imx6ull-pro" title="永久链接至标题">¶</a></h5>
<p>  LED原理图如下，它使用GPIO5_IO03，引脚输出低电平时LED被点亮，输出高电平时LED被熄灭：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_067.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_067.png" />
&lt;400px&gt;</p>
</div>
<div class="section" id="atk-imx6ull-alpha">
<h5>正点原子Atk_imx6ull-alpha开发板<a class="headerlink" href="#atk-imx6ull-alpha" title="永久链接至标题">¶</a></h5>
<p>  LED原理图如下，它使用GPIO1_IO03，引脚输出低电平时LED被点亮，输出高电平时LED被熄灭：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_068.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_068.png" />
&lt;800px&gt;</p>
</div>
</div>
<div class="section" id="id48">
<h4>所涉及的寄存器操作<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h4>
<p>  GPIO模块图如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" />
&lt;600px&gt;</p>
<p>  代码中对硬件的操作截图如下，截图便于对比，后面有文字便于复制：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_069.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_069.png" />
&lt;800px&gt;</p>
<div class="section" id="font-color-dd0000-fire-imx6ull-pro-font">
<h5><font color="#dd0000">野火fire_imx6ull-pro</font> 开发板<a class="headerlink" href="#font-color-dd0000-fire-imx6ull-pro-font" title="永久链接至标题">¶</a></h5>
<p>  步骤1：使能GPIO5</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_070.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_070.png" />
&lt;600px&gt;</p>
<p>    设置b[31:30]就可以使能GPIO5，设置为什么值呢？</p>
<p>    看下图，设置为0b11：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" />
&lt;400px&gt;</p>
<p>      ① 00：该GPIO模块全程被关闭</p>
<p>      ② 01：该GPIO模块在CPU run mode情况下是使能的；在WAIT或STOP模式下，关闭</p>
<p>      ③ 10：保留</p>
<p>      ④ 11：该GPIO模块全程使能</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* GPIO5_IO03 */</span>   
	<span class="cm">/* a. 使能GPIO5   </span>
<span class="cm">	 * set CCM to enable GPIO5   </span>
<span class="cm">	 * CCM_CCGR1[CG15] 0x20C406C   </span>
<span class="cm">	 * bit[31:30] = 0b11   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  步骤2：设置GPIO5_IO03为GPIO模式</p>
<p>    设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_071.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_071.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* b. 设置GPIO5_IO03用于GPIO   </span>
<span class="cm">	 * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3   </span>
<span class="cm">	 *		to configure GPIO5_IO03 as GPIO   </span>
<span class="cm">	 * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3	0x2290014   </span>
<span class="cm">	 * bit[3:0] = 0b0101 alt5   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  步骤3：设置GPIO5_IO03为输出引脚，设置其输出电平</p>
<p>    寄存器地址为：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" />
&lt;600px&gt;</p>
<p>    设置方向寄存器，把引脚设置为输出引脚：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" />
&lt;600px&gt;</p>
<p>    设置数据寄存器，设置引脚的输出电平：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_074.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_074.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* c. 设置GPIO5_IO03作为output引脚   </span>
<span class="cm">	 * set GPIO5_GDIR to configure GPIO5_IO03 as output   </span>
<span class="cm">	 * GPIO5_GDIR  0x020AC000 + 0x4   </span>
<span class="cm">	 * bit[3] = 0b1   </span>
<span class="cm">	 */</span>   
   
	<span class="cm">/* d. 设置GPIO5_DR输出低电平   </span>
<span class="cm">	 * set GPIO5_DR to configure GPIO5_IO03 output 0   </span>
<span class="cm">	 * GPIO5_DR 0x020AC000 + 0   </span>
<span class="cm">	 * bit[3] = 0b0   </span>
<span class="cm">	 */</span>   
	   
	<span class="cm">/* e. 设置GPIO5_IO3输出高电平   </span>
<span class="cm">	 * set GPIO5_DR to configure GPIO5_IO03 output 1   </span>
<span class="cm">	 * GPIO5_DR 0x020AC000 + 0   </span>
<span class="cm">	 * bit[3] = 0b1   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
</div>
<div class="section" id="font-color-dd0000-atk-imx6ull-alpha-font">
<h5><font color="#dd0000">正点原子Atk_imx6ull-alpha</font>开发板<a class="headerlink" href="#font-color-dd0000-atk-imx6ull-alpha-font" title="永久链接至标题">¶</a></h5>
<p>  步骤1：使能GPIO1</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_075.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_075.png" />
&lt;600px&gt;</p>
<p>    设置b[27:26]就可以使能GPIO1，设置为什么值呢？</p>
<p>    看下图，设置为0b11：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" />
&lt;400px&gt;</p>
<p>      ① 00：该GPIO模块全程被关闭</p>
<p>      ② 01：该GPIO模块在CPU run mode情况下是使能的；在WAIT或STOP模式下，关闭</p>
<p>      ③ 10：保留</p>
<p>      ④ 11：该GPIO模块全程使能</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* GPIO1_IO03 */</span>   
	<span class="cm">/* a. 使能GPIO1   </span>
<span class="cm">	 * set CCM to enable GPIO1   </span>
<span class="cm">	 * CCM_CCGR1[CG13] 0x20C406C   </span>
<span class="cm">	 * bit[27:26] = 0b11   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  步骤2：设置GPIO1_IO03为GPIO模式</p>
<p>    设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_076.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_076.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* b. 设置GPIO1_IO03用于GPIO   </span>
<span class="cm">	 * set IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03   </span>
<span class="cm">	 *		to configure GPIO1_IO03 as GPIO   </span>
<span class="cm">	 * IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03  0x20E0068   </span>
<span class="cm">	 * bit[3:0] = 0b0101 alt5   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
<p>  步骤3：设置GPIO1_IO03为输出引脚，设置其输出电平</p>
<p>    寄存器地址为：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" />
&lt;600px&gt;</p>
<p>    设置方向寄存器，把引脚设置为输出引脚：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" />
&lt;600px&gt;</p>
<p>    设置数据寄存器，设置引脚的输出电平：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_074.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_074.png" />
&lt;600px&gt;</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="cm">/* c. 设置GPIO1_IO03作为output引脚   </span>
<span class="cm">	 * set GPIO1_GDIR to configure GPIO1_IO03 as output   </span>
<span class="cm">	 * GPIO1_GDIR  0x0209C000 + 0x4   </span>
<span class="cm">	 * bit[3] = 0b1   </span>
<span class="cm">	 */</span>   
	   
	<span class="cm">/* d. 设置GPIO1_DR输出低电平   </span>
<span class="cm">	 * set GPIO1_DR to configure GPIO1_IO03 output 0   </span>
<span class="cm">	 * GPIO1_DR 0x0209C000 + 0   </span>
<span class="cm">	 * bit[3] = 0b0   </span>
<span class="cm">	 */</span>   
	   
	<span class="cm">/* e. 设置GPIO1_IO03输出高电平   </span>
<span class="cm">	 * set GPIO1_DR to configure GPIO1_IO03 output 1   </span>
<span class="cm">	 * GPIO1_DR 0x0209C000 + 0   </span>
<span class="cm">	 * bit[3] = 0b1   </span>
<span class="cm">	 */</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id49">
<h4>写程序<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h4>
<div class="section" id="id50">
<h5><font color="#dd0000">野火fire_imx6ull-pro</font>开发板<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>2_led_drv<span class="se">\ </span>  
	  	02_led_drv_for_boards<span class="se">\f</span>ire_imx6ull-pro_src_bin   
</pre></div>
</div>
<p>  硬件相关的文件是board_fire_imx6ull-pro.c，其他文件跟LED框架驱动程序完全一样。</p>
<p>  它首先构造了一个led_operations结构体，用来表示LED的硬件操作：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">100</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="n">board_demo_led_opr</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">101</span>    <span class="p">.</span><span class="n">num</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
	<span class="mi">102</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_demo_led_init</span><span class="p">,</span>   
	<span class="mi">103</span>    <span class="p">.</span><span class="n">ctl</span>  <span class="o">=</span> <span class="n">board_demo_led_ctl</span><span class="p">,</span>   
	<span class="mi">104</span> <span class="p">};</span>   
	<span class="mi">105</span>   
</pre></div>
</div>
<p>  led_operations结构体中有init函数指针，它指向board_demo_led_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。</p>
<p>  值得关注的是第35～38行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">21</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">CCM_CCGR1</span>                       <span class="p">;</span>   
	<span class="mi">22</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</span><span class="p">;</span>   
	<span class="mi">23</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO5_GDIR</span>                      <span class="p">;</span>   
	<span class="mi">24</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO5_DR</span>                        <span class="p">;</span>   
	<span class="mi">25</span>   
	<span class="mi">26</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化LED, which-哪个LED */</span>      
	<span class="mi">27</span> <span class="p">{</span>   
	<span class="mi">28</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>   
	<span class="mi">29</span>   
	<span class="mi">30</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   </span>
	<span class="mi">31</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">32</span>    <span class="p">{</span>   
	<span class="mi">33</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CCM_CCGR1</span><span class="p">)</span>   
	<span class="mi">34</span>       <span class="p">{</span>   
	<span class="mi">35</span>          <span class="n">CCM_CCGR1</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20C406C</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">36</span>       <span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x2290014</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">37</span>          <span class="n">GPIO5_GDIR</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x020AC000</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">38</span>          <span class="n">GPIO5_DR</span>   <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x020AC000</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">39</span>       <span class="p">}</span>   
	<span class="mi">40</span>   
	<span class="mi">41</span>       <span class="cm">/* GPIO5_IO03 */</span>   
	<span class="mi">42</span>       <span class="cm">/* a. 使能GPIO5   </span>
<span class="cm">	43        * set CCM to enable GPIO5   </span>
<span class="cm">	44        * CCM_CCGR1[CG15] 0x20C406C   </span>
<span class="cm">	45        * bit[31:30] = 0b11   </span>
<span class="cm">	46        */</span>   
	<span class="mi">47</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">);</span>   
	<span class="mi">48</span>   
	<span class="mi">49</span>       <span class="cm">/* b. 设置GPIO5_IO03用于GPIO   </span>
<span class="cm">	50        * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3   </span>
<span class="cm">	51        *     to configure GPIO5_IO03 as GPIO   </span>
<span class="cm">	52        * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3  0x2290014   </span>
<span class="cm">	53        * bit[3:0] = 0b0101 alt5   </span>
<span class="cm">	54        */</span>   
	<span class="mi">55</span>       <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</span><span class="p">;</span>   
	<span class="mi">56</span>       <span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xf</span><span class="p">);</span>   
	<span class="mi">57</span>       <span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>   
	<span class="mi">58</span>       <span class="o">*</span><span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>   
	<span class="mi">59</span>   
	<span class="mi">60</span>   
	<span class="mi">61</span>       <span class="cm">/* b. 设置GPIO5_IO03作为output引脚   </span>
<span class="cm">	62        * set GPIO5_GDIR to configure GPIO5_IO03 as output   </span>
<span class="cm">	63        * GPIO5_GDIR  0x020AC000 + 0x4   </span>
<span class="cm">	64        * bit[3] = 0b1   </span>
<span class="cm">	65        */</span>   
	<span class="mi">66</span>       <span class="o">*</span><span class="n">GPIO5_GDIR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">67</span>    <span class="p">}</span>   
	<span class="mi">68</span>   
	<span class="mi">69</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">70</span> <span class="p">}</span>   
	<span class="mi">71</span>   
</pre></div>
</div>
<p>  led_operations结构体中有ctl函数指针，它指向board_demo_led_ctl函数，在里面将会根据参数设置LED引脚的输出电平：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">72</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">char</span> <span class="n">status</span><span class="p">)</span> <span class="cm">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span>   
	<span class="mi">73</span> <span class="p">{</span>   
	<span class="mi">74</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);   </span>
	<span class="mi">75</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">76</span>    <span class="p">{</span>   
	<span class="mi">77</span>       <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="cm">/* on: output 0*/</span>   
	<span class="mi">78</span>       <span class="p">{</span>   
	<span class="mi">79</span>          <span class="cm">/* d. 设置GPIO5_DR输出低电平   </span>
<span class="cm">	80           * set GPIO5_DR to configure GPIO5_IO03 output 0   </span>
<span class="cm">	81           * GPIO5_DR 0x020AC000 + 0   </span>
<span class="cm">	82           * bit[3] = 0b0   </span>
<span class="cm">	83           */</span>   
	<span class="mi">84</span>          <span class="o">*</span><span class="n">GPIO5_DR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">85</span>       <span class="p">}</span>   
	<span class="mi">86</span>       <span class="k">else</span>  <span class="cm">/* off: output 1*/</span>   
	<span class="mi">87</span>       <span class="p">{</span>   
	<span class="mi">88</span>          <span class="cm">/* e. 设置GPIO5_IO3输出高电平   </span>
<span class="cm">	89           * set GPIO5_DR to configure GPIO5_IO03 output 1   </span>
<span class="cm">	90           * GPIO5_DR 0x020AC000 + 0   </span>
<span class="cm">	91           * bit[3] = 0b1   </span>
<span class="cm">	92           */</span>   
	<span class="mi">93</span>          <span class="o">*</span><span class="n">GPIO5_DR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">94</span>       <span class="p">}</span>   
	<span class="mi">95</span>   
	<span class="mi">96</span>    <span class="p">}</span>   
	<span class="mi">97</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">98</span> <span class="p">}</span>   
	<span class="mi">99</span>   
</pre></div>
</div>
<p>  下面的get_board_led_opr函数供上层调用，给上层提供led_operations结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">106</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="o">*</span><span class="nf">get_board_led_opr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mi">107</span> <span class="p">{</span>   
	<span class="mi">108</span>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">;</span>   
	<span class="mi">109</span> <span class="p">}</span>   
	<span class="mi">110</span>   
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h5><font color="#dd0000">正点原子Atk_imx6ull-alpha</font>开发板<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>2_led_drv<span class="se">\ </span>  
	     02_led_drv_for_boards<span class="se">\a</span>tk_imx6ull-alpha_src_bin   
</pre></div>
</div>
<p>  硬件相关的文件是board_atk_imx6ull-alpha.c，其他文件跟LED框架驱动程序完全一样。</p>
<p>  它首先构造了一个led_operations结构体，用来表示LED的硬件操作：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">100</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="n">board_demo_led_opr</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">101</span>    <span class="p">.</span><span class="n">num</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
	<span class="mi">102</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_demo_led_init</span><span class="p">,</span>   
	<span class="mi">103</span>    <span class="p">.</span><span class="n">ctl</span>  <span class="o">=</span> <span class="n">board_demo_led_ctl</span><span class="p">,</span>   
	<span class="mi">104</span> <span class="p">};</span>   
	<span class="mi">105</span>   
</pre></div>
</div>
<p>  led_operations结构体中有init函数指针，它指向board_demo_led_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。</p>
<p>  值得关注的是第35～38行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">26</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化LED, which-哪个LED */</span>   
	<span class="mi">27</span> <span class="p">{</span>   
	<span class="mi">28</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>   
	<span class="mi">29</span>   
	<span class="mi">30</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   </span>
	<span class="mi">31</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">32</span>    <span class="p">{</span>   
	<span class="mi">33</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CCM_CCGR1</span><span class="p">)</span>   
	<span class="mi">34</span>       <span class="p">{</span>   
	<span class="mi">35</span>          <span class="n">CCM_CCGR1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20C406C</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">36</span>          <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20E0068</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">37</span>          <span class="n">GPIO1_GDIR</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x0209C000</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">38</span>          <span class="n">GPIO1_DR</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x0209C000</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">39</span>       <span class="p">}</span>   
	<span class="mi">40</span>   
	<span class="mi">41</span>       <span class="cm">/* GPIO1_IO03 */</span>   
	<span class="mi">42</span>       <span class="cm">/* a. 使能GPIO1   </span>
<span class="cm">	43        * set CCM to enable GPIO1   </span>
<span class="cm">	44        * CCM_CCGR1[CG13] 0x20C406C   </span>
<span class="cm">	45        * bit[27:26] = 0b11   </span>
<span class="cm">	46        */</span>   
	<span class="mi">47</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">);</span>   
	<span class="mi">48</span>   
	<span class="mi">49</span>       <span class="cm">/* b. 设置GPIO1_IO03用于GPIO   </span>
<span class="cm">	50        * set IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03   </span>
<span class="cm">	51        *     to configure GPIO1_IO03 as GPIO   </span>
<span class="cm">	52        * IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03  0x20E0068   </span>
<span class="cm">	53        * bit[3:0] = 0b0101 alt5   </span>
<span class="cm">	54        */</span>   
	<span class="mi">55</span>       <span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span><span class="p">;</span>   
	<span class="mi">56</span>       <span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xf</span><span class="p">);</span>   
	<span class="mi">57</span>       <span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>   
	<span class="mi">58</span>       <span class="o">*</span><span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>   
	<span class="mi">59</span>   
	<span class="mi">60</span>   
	<span class="mi">61</span>       <span class="cm">/* c. 设置GPIO1_IO03作为output引脚   </span>
<span class="cm">	62        * set GPIO1_GDIR to configure GPIO1_IO03 as output   </span>
<span class="cm">	63        * GPIO1_GDIR  0x0209C000 + 0x4   </span>
<span class="cm">	64        * bit[3] = 0b1   </span>
<span class="cm">	65        */</span>   
	<span class="mi">66</span>       <span class="o">*</span><span class="n">GPIO1_GDIR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">67</span>    <span class="p">}</span>   
	<span class="mi">68</span>   
	<span class="mi">69</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">70</span> <span class="p">}</span>   
	<span class="mi">71</span>   
</pre></div>
</div>
<p>  led_operations结构体中有ctl函数指针，它指向board_demo_led_ctl函数，在里面将会根据参数设置LED引脚的输出电平：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">72</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">char</span> <span class="n">status</span><span class="p">)</span> <span class="cm">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span>   
	<span class="mi">73</span> <span class="p">{</span>   
	<span class="mi">74</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);   </span>
	<span class="mi">75</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">76</span>    <span class="p">{</span>   
	<span class="mi">77</span>       <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="cm">/* on: output 0*/</span>   
	<span class="mi">78</span>       <span class="p">{</span>   
	<span class="mi">79</span>          <span class="cm">/* d. 设置GPIO1_DR输出低电平   </span>
<span class="cm">	80           * set GPIO1_DR to configure GPIO1_IO03 output 0   </span>
<span class="cm">	81           * GPIO1_DR 0x0209C000 + 0   </span>
<span class="cm">	82           * bit[3] = 0b0   </span>
<span class="cm">	83           */</span>   
	<span class="mi">84</span>          <span class="o">*</span><span class="n">GPIO1_DR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">85</span>       <span class="p">}</span>   
	<span class="mi">86</span>       <span class="k">else</span>  <span class="cm">/* off: output 1*/</span>   
	<span class="mi">87</span>       <span class="p">{</span>   
	<span class="mi">88</span>          <span class="cm">/* e. 设置GPIO1_IO03输出高电平   </span>
<span class="cm">	89           * set GPIO1_DR to configure GPIO1_IO03 output 1   </span>
<span class="cm">	90           * GPIO1_DR 0x0209C000 + 0   </span>
<span class="cm">	91           * bit[3] = 0b1   </span>
<span class="cm">	92           */</span>   
	<span class="mi">93</span>          <span class="o">*</span><span class="n">GPIO1_DR</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">94</span>       <span class="p">}</span>   
	<span class="mi">95</span>   
	<span class="mi">96</span>    <span class="p">}</span>   
	<span class="mi">97</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">98</span> <span class="p">}</span>   
	<span class="mi">99</span>   
</pre></div>
</div>
<p>  下面的get_board_led_opr函数供上层调用，给上层提供led_operations结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mo">06</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="o">*</span><span class="nf">get_board_led_opr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mo">07</span> <span class="p">{</span>   
	<span class="mi">08</span>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">;</span>   
	<span class="mi">09</span> <span class="p">}</span>   
	<span class="mi">10</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id52">
<h4>上机实验<a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h4>
<p>  首先设置工具链，然后修改驱动程序Makefile指定内核源码路径，就可以编译驱动程序和测试程序了。</p>
<p>  启动开发板，挂载NFS文件系统，这样就可以访问到Ubuntu中的文件。</p>
<p>  最后，就可以在开发板上进行下列测试。</p>
<div class="section" id="id53">
<h5><font color="#dd0000">野火fire_imx6ull-pro</font> 开发板<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h5>
<p>  <font color="# dd0000">注意：</font>如果要使用板子自带的系统，关闭原有LED驱动的方法是类似的，也是进入开发板/sys/class/leds/目录，对于每一个LED在该目录下都有一个子目录，假设某个子目录名为XXX，则执行如下命令：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo none  &gt;  /sys/class/leds/XXX/trigger   </span>
</pre></div>
</div>
<p>  使用我们的系统时，按如下操作。</p>
<p>  要先禁止内核中原来的LED驱动，把“heatbeat”功能关闭，执行以下命令即可：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo none &gt; /sys/class/leds/cpu/trigger   </span>
</pre></div>
</div>
<p>  这样就可以使用我们的驱动程序做实验了：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  insmod  100ask_led.ko   </span>
	<span class="c1"># ./ledtest  /dev/100ask_led0  on   </span>
	<span class="c1"># ./ledtest  /dev/100ask_led0  off   </span>
</pre></div>
</div>
<p>  如果想恢复原来的心跳功能，可以执行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo heartbeat &gt; /sys/class/leds/cpu/trigger   </span>
</pre></div>
</div>
</div>
<div class="section" id="id54">
<h5><font color="#dd0000">正点原子Atk_imx6ull-alpha</font>开发板<a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h5>
<p>  <font color="# dd0000">注意：</font>如果要使用板子自带的系统，关闭原有LED驱动的方法是类似的，也是进入开发板/sys/class/leds/目录，对于每一个LED在该目录下都有一个子目录，假设某个子目录名为XXX，则执行如下命令：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo none  &gt;  /sys/class/leds/XXX/trigger   </span>
</pre></div>
</div>
<p>  使用我们的系统时，按如下操作。</p>
<p>  要先禁止内核中原来的LED驱动，把“heatbeat”功能关闭，执行以下命令即可：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo none &gt; /sys/class/leds/sys-led/trigger   </span>
</pre></div>
</div>
<p>  这样就可以使用我们的驱动程序做实验了：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  insmod  100ask_led.ko   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  on   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  off   </span>
</pre></div>
</div>
<p>  如果想恢复原来的心跳功能，可以执行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  echo heartbeat &gt; /sys/class/leds/sys-led/trigger   </span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id55">
<h4>课后作业<a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h4>
<p>  a. 在驱动里有ioremap，什么时候执行iounmap？请完善程序</p>
<p>  b. 视频里我们只实现了点一个LED，开发板上也只有一个LED，</p>
<p>  所以，请修改代码操作蜂鸣器。</p>
</div>
</div>
<div class="section" id="imx6ull-qemuled">
<h3>百问网IMX6ULL-QEMU的LED驱动程序<a class="headerlink" href="#imx6ull-qemuled" title="永久链接至标题">¶</a></h3>
<p>  使用QEMU模拟的硬件，它的硬件资源可以随意扩展。</p>
<p>  在IMX6ULL QEMU 虚拟开发板上，我们为它设计了4个 LED。</p>
<div class="section" id="id56">
<h4>看原理图确定引脚及操作方法<a class="headerlink" href="#id56" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_077.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_077.png" />
&lt;400px&gt;
  从上图可知，这4个 LED 用到了GPIO5_3、GPIO1_3、GPIO1_5、GPIO1_6 共4个引脚。</p>
<p>  在芯片手册里，这些引脚的名字是：GPIO5_IO03、GPIO1_IO03、GPIO1_IO05、GPIO1_IO06。可以根据名字搜到对应的寄存器。</p>
<p>  当这些引脚输出低电平时，对应的LED被点亮；输出高电平时，LED熄灭。</p>
</div>
<div class="section" id="id57">
<h4>所涉及的寄存器操作<a class="headerlink" href="#id57" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" />
&lt;600px&gt;
  步骤1：使能GPIO1、GPIO5</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_078.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_078.png" />
&lt;600px&gt;</p>
<p>    设置b[31:30]、b[27:26]就可以使能GPIO5、GPIO1，设置为什么值呢？</p>
<p>    看下图，设置为0b11：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_024.png" />
&lt;400px&gt;</p>
<p>      ① 00：该GPIO模块全程被关闭</p>
<p>      ② 01：该GPIO模块在CPU run mode情况下是使能的；在WAIT或STOP模式下，关闭</p>
<p>      ③ 10：保留</p>
<p>      ④ 11：该GPIO模块全程使能</p>
<p>  步骤2：设置GPIO5_IO03、GPIO1_IO03、GPIO1_IO05、GPIO1_IO06为GPIO模式</p>
<p>    ① 对于GPIO5_IO03，设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_071.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_071.png" />
&lt;600px&gt;</p>
<p>    ② 对于GPIO1_IO03，设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_076.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_076.png" />
&lt;600px&gt;</p>
<p>    ③ 对于GPIO1_IO05，设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_079.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_079.png" />
&lt;600px&gt;</p>
<p>    ④ 对于GPIO1_IO06，设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_080.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_080.png" />
&lt;600px&gt;</p>
<p>  步骤3：设置GPIO5_IO03、GPIO1_IO03、GPIO1_IO05、GPIO1_IO06为输出引脚，设置其输出电平</p>
<p>    寄存器地址为：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" />
&lt;600px&gt;</p>
<p>    设置方向寄存器，把引脚设置为输出引脚：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" />
&lt;600px&gt;</p>
<p>    设置数据寄存器，设置引脚的输出电平：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_074.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_074.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id58">
<h4>写程序<a class="headerlink" href="#id58" title="永久链接至标题">¶</a></h4>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01</span><span class="n">_all_series_quickstart</span>\<span class="mi">04</span><span class="n">_快速入门</span><span class="p">(</span><span class="n">正式开始</span><span class="p">)</span>\   
<span class="mi">02</span><span class="n">_嵌入式Linux驱动开发基础知识</span>\<span class="n">source</span>\<span class="mi">02</span><span class="n">_led_drv</span>\   
     <span class="mi">02</span><span class="n">_led_drv_for_boards</span>\<span class="mi">100</span><span class="n">ask_imx6ull</span><span class="o">-</span><span class="n">qemu_src_bin</span>
</pre></div>
</div>
<p>  硬件相关的文件是board_100ask_imx6ull-qemu.c，其他文件跟LED框架驱动程序完全一样。</p>
<p>  涉及的寄存器挺多，一个一个去执行ioremap效率太低。</p>
<p>  先定义结构体，然后对结构体指针进行ioremap，这些结构体在。</p>
<p>  对于IOMUXC，可以如下定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="k">struct</span> <span class="n">iomux</span> <span class="p">{</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unnames</span><span class="p">[</span><span class="mi">23</span><span class="p">];</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09</span><span class="p">;</span>   
	<span class="p">};</span>   
   
	<span class="k">struct</span> <span class="n">iomux</span>  <span class="o">*</span><span class="n">iomux</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20e0000</span><span class="p">,</span>  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iomux</span><span class="p">));</span>   
</pre></div>
</div>
<p>  对于GPIO，可以如下定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="p">{</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gdir</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">psr</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icr1</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icr2</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">imr</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">isr</span><span class="p">;</span>   
		<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">edge_sel</span><span class="p">;</span>   
	<span class="p">};</span>   
	<span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="o">*</span><span class="n">gpio1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x209C000</span><span class="p">,</span>  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
	<span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="o">*</span><span class="n">gpio5</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20AC000</span><span class="p">,</span>  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
</pre></div>
</div>
<p>  开始详细分析board_100ask_imx6ull-qemu.c。</p>
<p>  它首先构造了一个led_operations结构体，用来表示LED的硬件操作：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">176</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="n">board_demo_led_opr</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">177</span>    <span class="p">.</span><span class="n">num</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>   
	<span class="mi">178</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_demo_led_init</span><span class="p">,</span>   
	<span class="mi">179</span>    <span class="p">.</span><span class="n">ctl</span>  <span class="o">=</span> <span class="n">board_demo_led_ctl</span><span class="p">,</span>   
	<span class="mi">180</span> <span class="p">};</span>   
	<span class="mi">181</span>   
</pre></div>
</div>
<p>  led_operations结构体中有init函数指针，它指向board_demo_led_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。</p>
<p>  值得关注的是第61～66行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">57</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化LED, which-哪个LED */</span>   
	<span class="mi">58</span> <span class="p">{</span>   
	<span class="mi">59</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CCM_CCGR1</span><span class="p">)</span>   
	<span class="mi">60</span>    <span class="p">{</span>   
	<span class="mi">61</span>       <span class="n">CCM_CCGR1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20C406C</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">62</span>       <span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x2290014</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
	<span class="mi">63</span>   
	<span class="mi">64</span>       <span class="n">iomux</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20e0000</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iomux</span><span class="p">));</span>   
	<span class="mi">65</span>       <span class="n">gpio1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x209C000</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
	<span class="mi">66</span>       <span class="n">gpio5</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20AC000</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
	<span class="mi">67</span>    <span class="p">}</span>   
	<span class="mi">68</span>   
	<span class="mi">69</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">70</span>    <span class="p">{</span>   
	<span class="mi">71</span>       <span class="cm">/* 1. enable GPIO5   </span>
<span class="cm">	72        * CG15, b[31:30] = 0b11   </span>
<span class="cm">	73        */</span>   
	<span class="mi">74</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">);</span>   
	<span class="mi">75</span>   
	<span class="mi">76</span>       <span class="cm">/* 2. set GPIO5_IO03 as GPIO   </span>
<span class="cm">	77        * MUX_MODE, b[3:0] = 0b101   </span>
<span class="cm">	78        */</span>   
	<span class="mi">79</span>       <span class="o">*</span><span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   
	<span class="mi">80</span>   
	<span class="mi">81</span>       <span class="cm">/* 3. set GPIO5_IO03 as output   </span>
<span class="cm">	82        * GPIO5 GDIR, b[3] = 0b1   </span>
<span class="cm">	83        */</span>   
	<span class="mi">84</span>       <span class="n">gpio5</span><span class="o">-&gt;</span><span class="n">gdir</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">85</span>    <span class="p">}</span>   
	<span class="mi">86</span>    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>   
	<span class="mi">87</span>    <span class="p">{</span>   
	<span class="mi">88</span>       <span class="cm">/* 1. enable GPIO1   </span>
<span class="cm">	89        * CG13, b[27:26] = 0b11   </span>
<span class="cm">	90        */</span>   
	<span class="mi">91</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">);</span>   
	<span class="mi">92</span>   
	<span class="mi">93</span>       <span class="cm">/* 2. set GPIO1_IO03 as GPIO   </span>
<span class="cm">	94        * MUX_MODE, b[3:0] = 0b101   </span>
<span class="cm">	95        */</span>   
	<span class="mi">96</span>       <span class="n">iomux</span><span class="o">-&gt;</span><span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   
	<span class="mi">97</span>   
	<span class="mi">98</span>       <span class="cm">/* 3. set GPIO1_IO03 as output   </span>
<span class="cm">	99        * GPIO1 GDIR, b[3] = 0b1   </span>
<span class="cm">	100        */</span>   
	<span class="mi">101</span>       <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">gdir</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">102</span>    <span class="p">}</span>   
	<span class="mi">103</span>    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>   
	<span class="mi">104</span>    <span class="p">{</span>   
	<span class="mi">105</span>       <span class="cm">/* 1. enable GPIO1   </span>
<span class="cm">	106        * CG13, b[27:26] = 0b11   </span>
<span class="cm">	107        */</span>   
	<span class="mi">108</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">);</span>   
	<span class="mi">109</span>   
	<span class="mi">110</span>       <span class="cm">/* 2. set GPIO1_IO05 as GPIO   </span>
<span class="cm">	111        * MUX_MODE, b[3:0] = 0b101   </span>
<span class="cm">	112        */</span>   
	<span class="mi">113</span>       <span class="n">iomux</span><span class="o">-&gt;</span><span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   
	<span class="mi">114</span>   
	<span class="mi">115</span>       <span class="cm">/* 3. set GPIO1_IO05 as output   </span>
<span class="cm">	116        * GPIO1 GDIR, b[5] = 0b1   </span>
<span class="cm">	117        */</span>   
	<span class="mi">118</span>       <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">gdir</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">);</span>   
	<span class="mi">119</span>    <span class="p">}</span>   
	<span class="mi">120</span>    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>   
	<span class="mi">121</span>    <span class="p">{</span>   
	<span class="mi">122</span>       <span class="cm">/* 1. enable GPIO1   </span>
<span class="cm">	123        * CG13, b[27:26] = 0b11   </span>
<span class="cm">	124        */</span>   
	<span class="mi">125</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">);</span>   
	<span class="mi">126</span>   
	<span class="mi">127</span>       <span class="cm">/* 2. set GPIO1_IO06 as GPIO   </span>
<span class="cm">	128        * MUX_MODE, b[3:0] = 0b101   </span>
<span class="cm">	129        */</span>   
	<span class="mi">130</span>       <span class="n">iomux</span><span class="o">-&gt;</span><span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   
	<span class="mi">131</span>   
	<span class="mi">132</span>       <span class="cm">/* 3. set GPIO1_IO06 as output   </span>
<span class="cm">	133        * GPIO1 GDIR, b[6] = 0b1   </span>
<span class="cm">	134        */</span>   
	<span class="mi">135</span>       <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">gdir</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">);</span>   
	<span class="mi">136</span>    <span class="p">}</span>   
	<span class="mi">137</span>   
	<span class="mi">138</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   </span>
	<span class="mi">139</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">140</span> <span class="p">}</span>   
	<span class="mi">141</span>   
</pre></div>
</div>
<p>  led_operations结构体中有ctl函数指针，它指向board_demo_led_ctl函数，在里面将会根据参数设置LED引脚的输出电平：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">142</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">char</span> <span class="n">status</span><span class="p">)</span> <span class="cm">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span>   
	<span class="mi">143</span> <span class="p">{</span>   
	<span class="mi">144</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);   </span>
	<span class="mi">145</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
	<span class="mi">146</span>    <span class="p">{</span>   
	<span class="mi">147</span>       <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>  <span class="cm">/* on : output 0 */</span>   
	<span class="mi">148</span>          <span class="n">gpio5</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">149</span>       <span class="k">else</span>       <span class="cm">/* on : output 1 */</span>   
	<span class="mi">150</span>          <span class="n">gpio5</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">151</span>    <span class="p">}</span>   
	<span class="mi">152</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>   
	<span class="mi">153</span>    <span class="p">{</span>   
	<span class="mi">154</span>       <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>  <span class="cm">/* on : output 0 */</span>   
	<span class="mi">155</span>          <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">156</span>       <span class="k">else</span>       <span class="cm">/* on : output 1 */</span>   
	<span class="mi">157</span>          <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
	<span class="mi">158</span>    <span class="p">}</span>   
	<span class="mi">159</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>   
	<span class="mi">160</span>    <span class="p">{</span>   
	<span class="mi">161</span>       <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>  <span class="cm">/* on : output 0 */</span>   
	<span class="mi">162</span>          <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">);</span>   
	<span class="mi">163</span>       <span class="k">else</span>       <span class="cm">/* on : output 1 */</span>   
	<span class="mi">164</span>          <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">);</span>   
	<span class="mi">165</span>    <span class="p">}</span>   
	<span class="mi">166</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>   
	<span class="mi">167</span>    <span class="p">{</span>   
	<span class="mi">168</span>       <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>  <span class="cm">/* on : output 0 */</span>   
	<span class="mi">169</span>          <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">);</span>   
	<span class="mi">170</span>       <span class="k">else</span>       <span class="cm">/* on : output 1 */</span>   
	<span class="mi">171</span>          <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">dr</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">);</span>   
	<span class="mi">172</span>    <span class="p">}</span>   
	<span class="mi">173</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">174</span> <span class="p">}</span>   
	<span class="mi">175</span>   
</pre></div>
</div>
<p>  下面的get_board_led_opr函数供上层调用，给上层提供led_operations结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">182</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="o">*</span><span class="nf">get_board_led_opr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mi">183</span> <span class="p">{</span>   
	<span class="mi">184</span>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">;</span>   
	<span class="mi">185</span> <span class="p">}</span>   
	<span class="mi">186</span>   
</pre></div>
</div>
</div>
<div class="section" id="id59">
<h4>上机实验<a class="headerlink" href="#id59" title="永久链接至标题">¶</a></h4>
<p>  先启动IMX6ULL QEMU模拟器，挂载NFS文件系统。</p>
<p>  运行QEMU时，</p>
<p>  QEMU内部为主机虚拟出一个网卡, IP为 10.0.2.2，</p>
<p>  IMX6ULL有一个网卡, IP为 10.0.2.15，</p>
<p>  它连接到主机的虚拟网卡。</p>
<p>  这样IMX6ULL就可以通过10.0.2.2去访问Ubuntu了。</p>
<p>  然后执行以下命令安装驱动、执行测试程序：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  insmod  100ask_led.ko   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  on   </span>
	<span class="c1">#  ./ledtest  /dev/100ask_led0  off   </span>
</pre></div>
</div>
</div>
<div class="section" id="id60">
<h4>课后作业<a class="headerlink" href="#id60" title="永久链接至标题">¶</a></h4>
<p>  a. 在驱动里有ioremap，什么时候执行iounmap？请完善程序</p>
<p>  b. 驱动程序中有太多的if判断，请优化程序减少if的使用</p>
</div>
</div>
</div>
<div class="section" id="id61">
<h2>驱动设计的思想：面向对象/分层/分离<a class="headerlink" href="#id61" title="永久链接至标题">¶</a></h2>
<div class="section" id="id62">
<h3>面向对象<a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h3>
<p>  字符设备驱动程序抽象出一个file_operations结构体；</p>
<p>  我们写的程序针对硬件部分抽象出led_operations结构体。</p>
</div>
<div class="section" id="id63">
<h3>分层<a class="headerlink" href="#id63" title="永久链接至标题">¶</a></h3>
<p>  上下分层，比如我们前面写的LED驱动程序就分为2层：</p>
<p>    ① 上层实现硬件无关的操作，比如注册字符设备驱动：leddrv.c</p>
<p>    ② 下层实现硬件相关的操作，比如board_A.c实现单板A的LED操作</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_081.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_081.png" />
&lt;400px&gt;</p>
</div>
<div class="section" id="id64">
<h3>分离<a class="headerlink" href="#id64" title="永久链接至标题">¶</a></h3>
<p>  还能不能改进？<font color="# dd0000">分离</font>。</p>
<p>  在board_A.c中，实现了一个led_operations，为LED引脚实现了初始化函数、控制函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="k">static</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="n">board_demo_led_opr</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="p">.</span><span class="n">num</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
		<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_demo_led_init</span><span class="p">,</span>   
		<span class="p">.</span><span class="n">ctl</span>  <span class="o">=</span> <span class="n">board_demo_led_ctl</span><span class="p">,</span>   
	<span class="p">};</span>   
</pre></div>
</div>
<p>  如果硬件上更换一个引脚来控制LED怎么办？你要去修改上面结构体中的init、ctl函数。</p>
<p>  实际情况是，每一款芯片它的GPIO操作都是类似的。比如：GPIO1_3、GPIO5_4这2个引脚接到LED：</p>
<p>    ① GPIO1_3属于第1组，即GPIO1。</p>
<p>      有方向寄存器DIR、数据寄存器DR等，基础地址是addr_base_addr_gpio1。</p>
<p>      设置为output引脚：修改GPIO1的DIR寄存器的bit3。</p>
<p>      设置输出电平：修改GPIO1的DR寄存器的bit3。</p>
<p>    ② GPIO5_4属于第5组，即GPIO5。</p>
<p>      有方向寄存器DIR、数据寄存器DR等，基础地址是addr_base_addr_gpio5。</p>
<p>      设置为output引脚：修改GPIO5的DIR寄存器的bit4。</p>
<p>      设置输出电平：修改GPIO5的DR寄存器的bit4。</p>
<p>      既然引脚操作那么有规律，并且这是跟主芯片相关的，那可以针对该芯片写出比较通用的硬件操作代码。</p>
<p>      比如board_A.c使用芯片chipY，那就可以写出：chipY_gpio.c，它实现芯片Y的GPIO操作，适用于芯片Y的所有GPIO引脚。</p>
<p>      使用时，我们只需要在board_A_led.c中指定使用哪一个引脚即可。</p>
<p>      程序结构如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_082.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_082.png" />
&lt;600px&gt;</p>
<p>      以面向对象的思想，在board_A_led.c中实现led_resouce结构体，它定义“资源”──要用哪一个引脚。</p>
<p>      在chipY_gpio.c中仍是实现led_operations结构体，它要写得更完善，支持所有GPIO。</p>
</div>
<div class="section" id="id65">
<h3>写示例代码<a class="headerlink" href="#id65" title="永久链接至标题">¶</a></h3>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>2_led_drv<span class="se">\0</span>3_led_drv_template_seperate   
</pre></div>
</div>
<p>  程序仍分为上下结构：上层leddrv.c向内核注册file_operations结构体；下层chip_demo_gpio.c提供led_operations结构体来操作硬件。</p>
<p>  下层的代码分为2个：chip_demo_gpio.c实现通用的GPIO操作，board_A_led.c指定使用哪个GPIO，即“资源”。</p>
<p>  led_resource.h中定义了led_resource结构体，用来描述GPIO：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	04 /* GPIO3_0 */   
	05 /* bit[31:16] = group */   
	06 /* bit[15:0]  = which pin */   
	07 # define GROUP(x) (x&gt;&gt;16)   
	08 # define PIN(x)   (x&amp;0xFFFF)   
	09 # define GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))   
	10   
	11 struct led_resource {   
	12     int pin;   
	13 };   
	14   
	15 struct led_resource *get_led_resouce(void);   
	16   
</pre></div>
</div>
<p>  board_A_led.c指定使用哪个GPIO，它实现一个led_resource结构体，并提供访问函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	02 # include &quot;led_resource.h&quot;   
	03   
	04 static struct led_resource board_A_led = {   
	05     .pin = GROUP_PIN(3,1),   
	06 };   
	07   
	08 struct led_resource *get_led_resouce(void)   
	09 {   
	10     return &amp;board_A_led;   
	11 }   
	12   
</pre></div>
</div>
<p>  chip_demo_gpio.c中，首先获得board_A_led.c实现的led_resource结构体，然后再进行其他操作，请看下面第26行：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">20</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">led_resource</span> <span class="o">*</span><span class="n">led_rsc</span><span class="p">;</span>   
	<span class="mi">21</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化LED, which-哪个LED */</span>   
	<span class="mi">22</span> <span class="p">{</span>   
	<span class="mi">23</span>     <span class="c1">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   </span>
	<span class="mi">24</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">led_rsc</span><span class="p">)</span>   
	<span class="mi">25</span>     <span class="p">{</span>   
	<span class="mi">26</span>           <span class="n">led_rsc</span> <span class="o">=</span> <span class="n">get_led_resouce</span><span class="p">();</span>   
	<span class="mi">27</span>     <span class="p">}</span>   
	<span class="mi">28</span>   
</pre></div>
</div>
</div>
<div class="section" id="id66">
<h3>课后作业<a class="headerlink" href="#id66" title="永久链接至标题">¶</a></h3>
<p>  使用“分离”的思想，去改造前面写的LED驱动程序：实现led_resouce，在里面可以指定要使用哪一个LED；改造led_operations，让它能支持更多GPIO。</p>
<p>  <font color="# dd0000">注意：</font>作为练习，led_operations结构体不需要写得很完善，不需要支持所有GPIO，你可以只支持若干个GPIO即可。</p>
</div>
</div>
<div class="section" id="id67">
<h2>驱动进化之路：总线设备驱动模型<a class="headerlink" href="#id67" title="永久链接至标题">¶</a></h2>
<p>  示例：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_083.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_083.png" />
&lt;800px&gt;</p>
<div class="section" id="id68">
<h3>驱动编写的3种方法<a class="headerlink" href="#id68" title="永久链接至标题">¶</a></h3>
<p>  以LED驱动为例：</p>
<div class="section" id="id69">
<h4>传统写法<a class="headerlink" href="#id69" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_084.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_084.png" />
&lt;600px&gt;
  使用哪个引脚，怎么操作引脚，都写死在代码中。</p>
<p>  最简单，不考虑扩展性，可以快速实现功能。</p>
<p>  修改引脚时，需要重新编译。</p>
</div>
<div class="section" id="id70">
<h4>总线设备驱动模型<a class="headerlink" href="#id70" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_085.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_085.png" />
&lt;600px&gt;
  引入platform_device/platform_driver，将“资源”与“驱动”分离开来。</p>
<p>  代码稍微复杂，但是易于扩展。</p>
<p>  冗余代码太多，修改引脚时设备端的代码需要重新编译。</p>
<p>  更换引脚时，上图中的led_drv.c基本不用改，但是需要修改led_dev.c</p>
</div>
<div class="section" id="id71">
<h4>设备树<a class="headerlink" href="#id71" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_086.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_086.png" />
&lt;600px&gt;
  通过配置文件──设备树来定义“资源”。</p>
<p>  代码稍微复杂，但是易于扩展。</p>
<p>  无冗余代码，修改引脚时只需要修改dts文件并编译得到dtb文件，把它传给内核。</p>
<p>  无需重新编译内核/驱动。</p>
</div>
</div>
<div class="section" id="linux-bus-dev-drv">
<h3>在Linux中实现“分离”：Bus/Dev/Drv模型<a class="headerlink" href="#linux-bus-dev-drv" title="永久链接至标题">¶</a></h3>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_087.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_087.png" />
&lt;1200px&gt;</p>
</div>
<div class="section" id="id72">
<h3>匹配规则<a class="headerlink" href="#id72" title="永久链接至标题">¶</a></h3>
<div class="section" id="platform-device-driver-overrideplatform-driver-driver-name">
<h4>最先比较：platform_device. driver_override和platform_driver.driver.name<a class="headerlink" href="#platform-device-driver-overrideplatform-driver-driver-name" title="永久链接至标题">¶</a></h4>
<p>  可以设置platform_device的driver_override，强制选择某个platform_driver。</p>
</div>
<div class="section" id="platform-device-nameplatform-driver-id-table-i-name">
<h4>然后比较：platform_device. name和platform_driver.id_table[i].name<a class="headerlink" href="#platform-device-nameplatform-driver-id-table-i-name" title="永久链接至标题">¶</a></h4>
<p>  Platform_driver.id_table是“platform_device_id”指针，表示该drv支持若干个device，它里面列出了各个device的<font color="# dd0000">{.name, .driver_data</font>}，其中的“name”表示该drv支持的设备的名字，driver_data是些提供给该device的私有数据。</p>
</div>
<div class="section" id="platform-device-nameplatform-driver-driver-name">
<h4>最后比较：platform_device.name和platform_driver.driver.name<a class="headerlink" href="#platform-device-nameplatform-driver-driver-name" title="永久链接至标题">¶</a></h4>
<p>  platform_driver.id_table可能为空，</p>
<p>  这时可以根据platform_driver.driver.name来寻找同名的platform_device。</p>
</div>
<div class="section" id="id73">
<h4>函数调用关系<a class="headerlink" href="#id73" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">platform_device_register</span>   
	<span class="n">platform_device_add</span>   
		<span class="n">device_add</span>   
			<span class="n">bus_add_device</span> <span class="c1">// 放入链表   </span>
			<span class="n">bus_probe_device</span>  <span class="c1">// probe枚举设备，即找到匹配的(dev, drv)   </span>
				<span class="n">device_initial_probe</span>   
					<span class="n">__device_attach</span>   
						<span class="n">bus_for_each_drv</span><span class="p">(...,</span><span class="n">__device_attach_driver</span><span class="p">,...)</span>   
							<span class="n">__device_attach_driver</span>   
								<span class="n">driver_match_device</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="c1">// 是否匹配   </span>
								<span class="n">driver_probe_device</span>       <span class="c1">// 调用drv的probe   </span>
   
<span class="n">platform_driver_register</span>   
	<span class="n">__platform_driver_register</span>   
		<span class="n">driver_register</span>   
			<span class="n">bus_add_driver</span> <span class="c1">// 放入链表   </span>
				<span class="n">driver_attach</span><span class="p">(</span><span class="n">drv</span><span class="p">)</span>   
						<span class="n">bus_for_each_dev</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">__driver_attach</span><span class="p">);</span>   
							<span class="n">__driver_attach</span>   
								<span class="n">driver_match_device</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="c1">// 是否匹配   </span>
								<span class="n">driver_probe_device</span>       <span class="c1">// 调用drv的probe   </span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id74">
<h3>常用函数<a class="headerlink" href="#id74" title="永久链接至标题">¶</a></h3>
<p>  这些函数可查看内核源码：drivers/base/platform.c，根据函数名即可知道其含义。</p>
<p>  下面摘取常用的几个函数。</p>
<div class="section" id="id75">
<h4>注册/反注册<a class="headerlink" href="#id75" title="永久链接至标题">¶</a></h4>
<p>  platform_device_register/ platform_device_unregister</p>
<p>  platform_driver_register/ platform_driver_unregister</p>
<p>  platform_add_devices // 注册多个device</p>
</div>
<div class="section" id="id76">
<h4>获得资源<a class="headerlink" href="#id76" title="永久链接至标题">¶</a></h4>
<p>  返回该dev中某类型(type)资源中的第几个(num)：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_088.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_088.png" />
&lt;600px&gt;</p>
<p>  返回该dev所用的第几个(num)中断：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_089.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_089.png" />
&lt;600px&gt;</p>
<p>  通过名字(name)返回该dev的某类型(type)资源：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_090.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_090.png" />
&lt;600px&gt;</p>
<p>  通过名字(name)返回该dev的中断号：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_091.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_091.png" />
&lt;600px&gt;</p>
</div>
</div>
<div class="section" id="id77">
<h3>怎么写程序<a class="headerlink" href="#id77" title="永久链接至标题">¶</a></h3>
<div class="section" id="platform-device">
<h4>分配/设置/注册platform_device结构体<a class="headerlink" href="#platform-device" title="永久链接至标题">¶</a></h4>
<p>  在里面定义所用资源，指定设备名字。</p>
</div>
<div class="section" id="platform-driver">
<h4>分配/设置/注册platform_driver结构体<a class="headerlink" href="#platform-driver" title="永久链接至标题">¶</a></h4>
<p>  在其中的probe函数里，分配/设置/注册file_operations结构体，</p>
<p>  并从platform_device中确实所用硬件资源。</p>
<p>  指定platform_driver的名字。</p>
</div>
</div>
<div class="section" id="id78">
<h3>课后作业<a class="headerlink" href="#id78" title="永久链接至标题">¶</a></h3>
<p>  在内核源码中搜索platform_device_register可以得到很多驱动，选择一个作为例子：</p>
<p>    ① 确定它的名字</p>
<p>    ② 根据它的名字找到对应的platform_driver</p>
<p>    ③ 进入platform_device_register/platform_driver_register内部，分析dev和drv的匹配过程</p>
</div>
</div>
<div class="section" id="id79">
<h2>LED模板驱动程序的改造：总线设备驱动模型<a class="headerlink" href="#id79" title="永久链接至标题">¶</a></h2>
<div class="section" id="id80">
<h3>原来的框架<a class="headerlink" href="#id80" title="永久链接至标题">¶</a></h3>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_092.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_092.png" />
&lt;800px&gt;</p>
</div>
<div class="section" id="id81">
<h3>要实现的框架===<a class="headerlink" href="#id81" title="永久链接至标题">¶</a></h3>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_093.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_093.png" />
&lt;800px&gt;</p>
</div>
<div class="section" id="id82">
<h3>写代码<a class="headerlink" href="#id82" title="永久链接至标题">¶</a></h3>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01</span><span class="n">_all_series_quickstart</span>\<span class="mi">04</span><span class="n">_快速入门</span><span class="p">(</span><span class="n">正式开始</span><span class="p">)</span>\   
<span class="mi">02</span><span class="n">_嵌入式Linux驱动开发基础知识</span>\<span class="n">source</span>\   
<span class="mi">02</span><span class="n">_led_drv</span>\<span class="mi">04</span><span class="n">_led_drv_template_bus_dev_drv</span>   
</pre></div>
</div>
<div class="section" id="id83">
<h4>注意事项<a class="headerlink" href="#id83" title="永久链接至标题">¶</a></h4>
<p>  ① 如果platform_device中不提供release函数，如下图所示不提供红框部分的函数：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_094.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_094.png" />
&lt;600px&gt;</p>
<p>    则在调用platform_device_unregister时会出现警告，如下图所示：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_095.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_095.png" />
&lt;600px&gt;</p>
<p>    你可以提供一个release函数，如果实在无事可做，把这函数写为空。</p>
<p>  ② EXPORT_SYMBOL</p>
<p>    a.c编译为a.ko，里面定义了func_a；如果它想让b.ko使用该函数，那么a.c里需要导出此函数(如果a.c, b.c都编进内核，则无需导出)：</p>
<p>    EXPORT_SYMBOL(led_device_create);</p>
<p>    并且，使用时要先加载a.ko。</p>
<p>    如果先加载b.ko，会有类似如下“Unknown symbol”的提示：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_096.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_096.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id84">
<h4>实现platform_device结构体<a class="headerlink" href="#id84" title="永久链接至标题">¶</a></h4>
<p>  board_A.c作为一个可加载模块，里面也有入口函数、出口函数。在入口函数中注册platform_device结构体，在platform_device结构体中指定使用哪个GPIO引脚。</p>
<p>  首先看入口函数，它调用platform_device_register函数，向内核注册board_A_led_dev结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">50</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">led_dev_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mi">51</span> <span class="p">{</span>   
	<span class="mi">52</span>    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>   
	<span class="mi">53</span>   
	<span class="mi">54</span>    <span class="n">err</span> <span class="o">=</span> <span class="n">platform_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_A_led_dev</span><span class="p">);</span>   
	<span class="mi">55</span>   
	<span class="mi">56</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">57</span> <span class="p">}</span>   
	<span class="mi">58</span>   
</pre></div>
</div>
<p>  board_A_led_dev结构体定义如下。</p>
<p>  在resouces数组中指定了2个引脚(第27～38行)；</p>
<p>  我们还提供了一个空函数led_dev_release(第23～25行)，它被赋给board_A_led_dev结构体(第46行)，这个函数在卸载platform_device时会被调用，如果不提供的话内核会打印警告信息。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">23</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">led_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>   
	<span class="mi">24</span> <span class="p">{</span>   
	<span class="mi">25</span> <span class="p">}</span>   
	<span class="mi">26</span>   
	<span class="mi">27</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">resource</span> <span class="n">resources</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">28</span>       <span class="p">{</span>   
	<span class="mi">29</span>             <span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">GROUP_PIN</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>   
	<span class="mi">30</span>             <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span>   
	<span class="mi">31</span>             <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;100ask_led_pin&quot;</span><span class="p">,</span>   
	<span class="mi">32</span>       <span class="p">},</span>   
	<span class="mi">33</span>       <span class="p">{</span>   
	<span class="mi">34</span>             <span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">GROUP_PIN</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span>   
	<span class="mi">35</span>             <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span>   
	<span class="mi">36</span>             <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;100ask_led_pin&quot;</span><span class="p">,</span>   
	<span class="mi">37</span>       <span class="p">},</span>   
	<span class="mi">38</span> <span class="p">};</span>   
	<span class="mi">39</span>   
	<span class="mi">40</span>   
	<span class="mi">41</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="n">board_A_led_dev</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">42</span>       <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;100ask_led&quot;</span><span class="p">,</span>   
	<span class="mi">43</span>       <span class="p">.</span><span class="n">num_resources</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">resources</span><span class="p">),</span>   
	<span class="mi">44</span>       <span class="p">.</span><span class="n">resource</span> <span class="o">=</span> <span class="n">resources</span><span class="p">,</span>   
	<span class="mi">45</span>       <span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">46</span>             <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">led_dev_release</span><span class="p">,</span>   
	<span class="mi">47</span>        <span class="p">},</span>   
	<span class="mi">48</span> <span class="p">};</span>   
	<span class="mi">49</span>   
</pre></div>
</div>
</div>
<div class="section" id="id85">
<h4>实现platform_driver结构体<a class="headerlink" href="#id85" title="永久链接至标题">¶</a></h4>
<p>  chip_demo_gpio.c中注册platform_driver结构体，它使用Bus/Dev/Drv模型，当有匹配的platform_device时，它的probe函数就会被调用。</p>
<p>  在probe函数中所做的事情跟之前的代码没有差别。</p>
<p>  先看入口函数。</p>
<p>  第150行向内核注册一个platform_driver结构体；</p>
<p>  这个结构体的核心在于第140行的chip_demo_gpio_probe函数。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">138</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">chip_demo_gpio_driver</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">139</span>    <span class="p">.</span><span class="n">probe</span>     <span class="o">=</span> <span class="n">chip_demo_gpio_probe</span><span class="p">,</span>   
	<span class="mi">140</span>    <span class="p">.</span><span class="n">remove</span>    <span class="o">=</span> <span class="n">chip_demo_gpio_remove</span><span class="p">,</span>   
	<span class="mi">141</span>    <span class="p">.</span><span class="n">driver</span>    <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">142</span>       <span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">&quot;100ask_led&quot;</span><span class="p">,</span>   
	<span class="mi">143</span>    <span class="p">},</span>   
	<span class="mi">144</span> <span class="p">};</span>   
	<span class="mi">145</span>   
	<span class="mi">146</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">chip_demo_gpio_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mi">147</span> <span class="p">{</span>   
	<span class="mi">148</span>    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>   
	<span class="mi">149</span>   
	<span class="mi">150</span>    <span class="n">err</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip_demo_gpio_driver</span><span class="p">);</span>   
	<span class="mi">151</span>    <span class="n">register_led_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">);</span>   
	<span class="mi">152</span>   
	<span class="mi">153</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">154</span> <span class="p">}</span>   
	<span class="mi">155</span>   
</pre></div>
</div>
<p>  chip_demo_gpio_probe函数代码如下。</p>
<p>  第107行：从匹配的platform_device中获取资源，确定GPIO引脚。</p>
<p>  第111行：把引脚记录下来，在操作硬件时要用。</p>
<p>  第112行：新发现了一个GPIO引脚，就调用上层驱动的代码创建设备节点。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">100</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">chip_demo_gpio_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>   
	<span class="mi">101</span> <span class="p">{</span>   
	<span class="mi">102</span>    <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>   
	<span class="mi">103</span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">104</span>   
	<span class="mi">105</span>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>   
	<span class="mi">106</span>    <span class="p">{</span>   
	<span class="mi">107</span>       <span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>   
	<span class="mi">108</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>   
	<span class="mi">109</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">110</span>   
	<span class="mi">111</span>       <span class="n">g_ledpins</span><span class="p">[</span><span class="n">g_ledcnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>   
	<span class="mi">112</span>       <span class="n">led_class_create_device</span><span class="p">(</span><span class="n">g_ledcnt</span><span class="p">);</span>   
	<span class="mi">113</span>       <span class="n">g_ledcnt</span><span class="o">++</span><span class="p">;</span>   
	<span class="mi">114</span>    <span class="p">}</span>   
	<span class="mi">115</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">116</span>   
	<span class="mi">117</span> <span class="p">}</span>   
	<span class="mi">118</span>   
</pre></div>
</div>
<p>  操作硬件的代码如下，第31、63行的代码里用到了数组g_ledpins，里面的值来自platform_device，在probe函数中根据platform_device的资源确定了引脚：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="mi">23</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">g_ledpins</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   
	<span class="mi">24</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">g_ledcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">25</span>   
	<span class="mi">26</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化LED, which-哪个LED */</span>   
	<span class="mi">27</span> <span class="p">{</span>   
	<span class="mi">28</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   </span>
	<span class="mi">29</span>   
	<span class="mi">30</span>   <span class="n">printk</span><span class="p">(</span><span class="s">&quot;init gpio: group %d, pin %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GROUP</span><span class="p">(</span><span class="n">g_ledpins</span><span class="p">[</span><span class="n">which</span><span class="p">]),</span> <span class="n">PIN</span><span class="p">(</span><span class="n">g_ledpins</span><span class="p">[</span><span class="n">which</span><span class="p">]));</span>   
	<span class="mi">31</span>    <span class="k">switch</span><span class="p">(</span><span class="n">GROUP</span><span class="p">(</span><span class="n">g_ledpins</span><span class="p">[</span><span class="n">which</span><span class="p">]))</span>   
	<span class="mi">32</span>    <span class="p">{</span>   
	<span class="mi">33</span>       <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>   
	<span class="mi">34</span>       <span class="p">{</span>   
	<span class="mi">35</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;init pin of group 0 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">36</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">37</span>       <span class="p">}</span>   
	<span class="mi">38</span>       <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>   
	<span class="mi">39</span>       <span class="p">{</span>   
	<span class="mi">40</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;init pin of group 1 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">41</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">42</span>       <span class="p">}</span>   
	<span class="mi">43</span>       <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>   
	<span class="mi">44</span>       <span class="p">{</span>   
	<span class="mi">45</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;init pin of group 2 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">46</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">47</span>       <span class="p">}</span>   
	<span class="mi">48</span>       <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>   
	<span class="mi">49</span>       <span class="p">{</span>   
	<span class="mi">50</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;init pin of group 3 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">51</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">52</span>       <span class="p">}</span>   
	<span class="mi">53</span>    <span class="p">}</span>   
	<span class="mi">54</span>   
	<span class="mi">55</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">56</span> <span class="p">}</span>   
	<span class="mi">57</span>   
	<span class="mi">58</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_demo_led_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">char</span> <span class="n">status</span><span class="p">)</span> <span class="cm">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span>   
	<span class="mi">59</span> <span class="p">{</span>   
	<span class="mi">60</span>    <span class="c1">//printk(&quot;%s %s line %d, led %d, %s\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &quot;on&quot; : &quot;off&quot;);   </span>
	<span class="mi">61</span>   <span class="n">printk</span><span class="p">(</span><span class="s">&quot;set led %s: group %d, pin %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">,</span> <span class="n">GROUP</span><span class="p">(</span><span class="n">g_ledpins</span><span class="p">[</span><span class="n">which</span><span class="p">]),</span> <span class="n">PIN</span><span class="p">(</span><span class="n">g_ledpins</span><span class="p">[</span><span class="n">which</span><span class="p">]));</span>   
	<span class="mi">62</span>   
	<span class="mi">63</span>    <span class="k">switch</span><span class="p">(</span><span class="n">GROUP</span><span class="p">(</span><span class="n">g_ledpins</span><span class="p">[</span><span class="n">which</span><span class="p">]))</span>   
	<span class="mi">64</span>    <span class="p">{</span>   
	<span class="mi">65</span>       <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>   
	<span class="mi">66</span>       <span class="p">{</span>   
	<span class="mi">67</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;set pin of group 0 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">68</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">69</span>       <span class="p">}</span>   
	<span class="mi">70</span>       <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>   
	<span class="mi">71</span>       <span class="p">{</span>   
	<span class="mi">72</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;set pin of group 1 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">73</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">74</span>       <span class="p">}</span>   
	<span class="mi">75</span>       <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>   
	<span class="mi">76</span>       <span class="p">{</span>   
	<span class="mi">77</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;set pin of group 2 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">78</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">79</span>       <span class="p">}</span>   
	<span class="mi">80</span>       <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>   
	<span class="mi">81</span>       <span class="p">{</span>   
	<span class="mi">82</span>          <span class="n">printk</span><span class="p">(</span><span class="s">&quot;set pin of group 3 ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>   
	<span class="mi">83</span>          <span class="k">break</span><span class="p">;</span>   
	<span class="mi">84</span>       <span class="p">}</span>   
	<span class="mi">85</span>    <span class="p">}</span>   
	<span class="mi">86</span>   
	<span class="mi">87</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
	<span class="mi">88</span> <span class="p">}</span>   
	<span class="mi">89</span>   
	<span class="mi">90</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="n">board_demo_led_opr</span> <span class="o">=</span> <span class="p">{</span>   
	<span class="mi">91</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_demo_led_init</span><span class="p">,</span>   
	<span class="mi">92</span>    <span class="p">.</span><span class="n">ctl</span>  <span class="o">=</span> <span class="n">board_demo_led_ctl</span><span class="p">,</span>   
	<span class="mi">93</span> <span class="p">};</span>   
	<span class="mi">94</span>   
	<span class="mi">95</span> <span class="k">struct</span> <span class="n">led_operations</span> <span class="o">*</span><span class="nf">get_board_led_opr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
	<span class="mi">96</span> <span class="p">{</span>   
	<span class="mi">97</span>    <span class="k">return</span> <span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">;</span>   
	<span class="mi">98</span> <span class="p">}</span>   
	<span class="mi">99</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id86">
<h3>课后作业<a class="headerlink" href="#id86" title="永久链接至标题">¶</a></h3>
<p>  完善半成品程序：04_led_drv_template_bus_dev_drv_unfinished。</p>
<p>  请仿照本节提供的程序(位于04_led_drv_template_bus_dev_drv目录)，改造你所用的单板的LED驱动程序。</p>
</div>
</div>
<div class="section" id="id87">
<h2>驱动进化之路：设备树的引入及简明教程<a class="headerlink" href="#id87" title="永久链接至标题">¶</a></h2>
<p>  官方文档(可以下载到devicetree-specification-v0.2.pdf): [](https://www.devicetree.org/specifications/ https://www.devicetree.org/specifications/)</p>
<p>  内核文档:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	Documentation/devicetree/booting-without-of.txt   
</pre></div>
</div>
<p>  我录制“设备树视频”时写的文档：设备树详细分析.txt</p>
<p>  这个txt文件也同步上传到wiki了：[](http://wiki.100ask.org/Linux_devicetree http://wiki.100ask.org/Linux_devicetree)</p>
<p>    我录制的设备树视频，它是基于s3c2440的，用的是linux 4.19；需要深入研究的可以看该视频(收费)。</p>
<p>    注意，如果只是想入门，看本文档及视频即可。</p>
<div class="section" id="id88">
<h3>设备树的引入与作用<a class="headerlink" href="#id88" title="永久链接至标题">¶</a></h3>
<p>  以LED驱动为例，如果你要更换LED所用的GPIO引脚，需要修改驱动程序源码、重新编译驱动、重新加载驱动。</p>
<p>  在内核中，使用同一个芯片的板子，它们所用的外设资源不一样，比如A板用GPIO A，B板用GPIO B。而GPIO的驱动程序既支持GPIO A也支持GPIO B，你需要指定使用哪一个引脚，怎么指定？在c代码中指定。</p>
<p>  随着ARM芯片的流行，内核中针对这些ARM板保存有大量的、没有技术含量的文件。</p>
<p>  Linus大发雷霆：”this whole ARM thing is a f*cking pain in the ass”。</p>
<p>  于是，Linux内核开始引入设备树。</p>
<p>  设备树并不是重新发明出来的，在Linux内核中其他平台如PowerPC，早就使用设备树来描述硬件了。</p>
<p>  Linus发火之后，内核开始全面使用设备树来改造，神人就神人。</p>
<p>  有一种错误的观点，说“新驱动都是用设备树来写了”。</p>
<p>  <font color="# dd0000">设备树不可能用来写驱动</font>。</p>
<p>  请想想，要操作硬件就需要去操作复杂的寄存器，如果设备树可以操作寄存器，那么它就是“驱动”，它就一样很复杂。</p>
<p>  设备树只是用来给内核里的驱动程序，<font color="# dd0000">指定硬件的信息</font>。比如LED驱动，在内核的驱动程序里去操作寄存器，但是操作哪一个引脚？这由设备树指定。</p>
<p>  你可以事先体验一下设备树，板子启动后执行下面的命令：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  ls /sys/firmware/   </span>
	devicetree  fdt   
</pre></div>
</div>
<p>  /sys/firmware/devicetree目录下是以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件。</p>
<p>  这些属性的值如果是字符串，可以使用cat命令把它打印出来；对于数值，可以用hexdump把它打印出来。</p>
<p>  一个单板启动时，u-boot先运行，它的作用是启动内核。U-boot会把内核和设备树文件都读入内存，然后启动内核。在启动内核时会把设备树在内存中的地址告诉内核。</p>
</div>
<div class="section" id="id89">
<h3>设备树的语法<a class="headerlink" href="#id89" title="永久链接至标题">¶</a></h3>
<p>  为什么叫“树”？</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_097.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_097.png" />
&lt;600px&gt;</p>
<p>  怎么描述这棵树？</p>
<p>  我们需要编写设备树文件(dts: device tree source)，它需要编译为dtb(device tree blob)文件，内核使用的是dtb文件。</p>
<p>  dts文件是根本，它的语法很简单。</p>
<p>  下面是一个设备树示例：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_098.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_098.png" />
&lt;800px&gt;</p>
<p>  它对应的dts文件如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_099.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_099.png" />
&lt;400px&gt;</p>
<div class="section" id="devicetree">
<h4>Devicetree格式<a class="headerlink" href="#devicetree" title="永久链接至标题">¶</a></h4>
<div class="section" id="dts">
<h5>DTS文件的格式<a class="headerlink" href="#dts" title="永久链接至标题">¶</a></h5>
<p>  DTS文件布局(layout):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	/dts-v1/<span class="p">;</span>            // 表示版本   
	<span class="o">[</span>memory reservations<span class="o">]</span>   // 格式为: /memreserve/ &lt;address&gt; &lt;length&gt;<span class="p">;</span>   
	/ <span class="o">{</span>   
	   <span class="o">[</span>property definitions<span class="o">]</span>   
	   <span class="o">[</span>child nodes<span class="o">]</span>   
	<span class="o">}</span><span class="p">;</span>   
</pre></div>
</div>
</div>
<div class="section" id="node">
<h5>node的格式<a class="headerlink" href="#node" title="永久链接至标题">¶</a></h5>
<p>  设备树中的基本单元，被称为“node”，其格式为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	[label:] node-name[@unit-address] {   
	   [properties definitions]   
	   [child nodes]   
	};   
</pre></div>
</div>
<p>  label是标号，可以省略。label的作用是为了方便地引用node，比如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	/dts-v1/;   
	/ {   
		uart0: uart@fe001000 {   
	      compatible=&quot;ns16550&quot;;   
	      reg=&lt;0xfe001000 0x100&gt;;   
		};   
	};   
</pre></div>
</div>
<p>  可以使用下面2种方法来修改uart&#64;fe001000这个node：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	// 在根节点之外使用label引用node：   
	&amp;uart0 {   
	   status = “disabled”;   
	};   
</pre></div>
</div>
<p>  或在根节点之外使用全路径：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		&amp;{/uart@fe001000}  {   
		   status = “disabled”;   
		};   
</pre></div>
</div>
</div>
<div class="section" id="properties">
<h5>properties的格式<a class="headerlink" href="#properties" title="永久链接至标题">¶</a></h5>
<p>  简单地说，properties就是“name=value”，value有多种取值方式。</p>
<p>  <strong>Property格式1:</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="p">[</span><span class="nl">label</span><span class="p">:]</span> <span class="n">property</span><span class="o">-</span><span class="n">name</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>   
</pre></div>
</div>
<p>  <strong>Property格式2(没有值):</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="p">[</span><span class="nl">label</span><span class="p">:]</span> <span class="n">property</span><span class="o">-</span><span class="n">name</span><span class="p">;</span>   
</pre></div>
</div>
<p>  Property取值只有3种</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		arrays of cells<span class="o">(</span>1个或多个32位数据, 64位数据使用2个32位数据表示<span class="o">)</span>,   
		string<span class="o">(</span>字符串<span class="o">)</span>,   
		bytestring<span class="o">(</span>1个或多个字节<span class="o">)</span>   
</pre></div>
</div>
<p>  <strong>示例</strong></p>
<p>  a. Arrays of cells : cell就是一个32位的数据，用<font color="# dd0000">尖括号</font>包围起来</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="n">interrupts</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mi">17</span> <span class="mh">0xc</span><span class="o">&gt;</span><span class="p">;</span>   
</pre></div>
</div>
<p>  b. 64bit数据使用2个cell来表示，用<font color="# dd0000">尖括号</font>包围起来:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="n">clock</span><span class="o">-</span><span class="n">frequency</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x00000001</span> <span class="mh">0x00000000</span><span class="o">&gt;</span><span class="p">;</span>   
</pre></div>
</div>
<p>  c. A null-terminated string (有结束符的字符串)，用双引号包围起来:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;simple-bus&quot;</span><span class="p">;</span>   
</pre></div>
</div>
<p>  d. A bytestring(字节序列) ，用<font color="# dd0000">中括号</font>包围起来:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="n">local</span><span class="o">-</span><span class="n">mac</span><span class="o">-</span><span class="n">address</span> <span class="o">=</span> <span class="p">[</span><span class="mo">00</span> <span class="mo">00</span> <span class="mi">12</span> <span class="mi">34</span> <span class="mi">56</span> <span class="mi">78</span><span class="p">];</span>  <span class="c1">// 每个byte使用2个16进制数来表示   </span>
	<span class="n">local</span><span class="o">-</span><span class="n">mac</span><span class="o">-</span><span class="n">address</span> <span class="o">=</span> <span class="p">[</span><span class="mo">00001234567</span><span class="mi">8</span><span class="p">];</span>      <span class="c1">// 每个byte使用2个16进制数来表示   </span>
</pre></div>
</div>
<p>  e. 可以是各种值的组合, 用<font color="# dd0000">逗号隔开</font>:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;ns16550&quot;</span><span class="p">,</span> <span class="s">&quot;ns8250&quot;</span><span class="p">;</span>   
	<span class="n">example</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0xf00f0000</span> <span class="mi">19</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">&quot;a strange property format&quot;</span><span class="p">;</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="dtsdtsi">
<h4>dts文件包含dtsi文件<a class="headerlink" href="#dtsdtsi" title="永久链接至标题">¶</a></h4>
<p>  设备树文件不需要我们从零写出来，内核支持了某款芯片比如imx6ull，在内核的arch/arm/boot/dts目录下就有了能用的设备树模板，一般命名为xxxx.dtsi。“i”表示“include”，被别的文件引用的。</p>
<p>  我们使用某款芯片制作出了自己的单板，所用资源跟xxxx.dtsi是大部分相同，小部分不同，所以需要引脚xxxx.dtsi并修改。</p>
<p>  dtsi文件跟dts文件的语法是完全一样的。</p>
<p>  dts中可以包含.h头文件，也可以包含dtsi文件，在.h头文件中可以定义一些宏。</p>
<p>  示例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	/dts-v1/;   
	   
	# include &lt;dt-bindings/input/input.h&gt;   
	# include &quot;imx6ull.dtsi&quot;   
	   
	/ {   
	……   
	};   
</pre></div>
</div>
</div>
<div class="section" id="id90">
<h4>常用的属性<a class="headerlink" href="#id90" title="永久链接至标题">¶</a></h4>
<div class="section" id="address-cells-size-cells">
<h5>address-cells、#size-cells<a class="headerlink" href="#address-cells-size-cells" title="永久链接至标题">¶</a></h5>
<p>  cell指一个32位的数值，</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		address-cells：address要用多少个32位数来表示；   
		size-cells：size要用多少个32位数来表示。   
</pre></div>
</div>
<p>  比如一段内存，怎么描述它的起始地址和大小？</p>
<p>  下例中，address-cells为1，所以reg中用1个数来表示地址，即用0x80000000来表示地址；size-cells为1，所以reg中用1个数来表示大小，即用0x20000000表示大小：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		/ {   
		# address-cells = &lt;1&gt;;   
		# size-cells = &lt;1&gt;;   
		memory {   
		reg = &lt;0x80000000 0x20000000&gt;;   
		   };   
		};   
</pre></div>
</div>
</div>
<div class="section" id="compatible">
<h5>compatible<a class="headerlink" href="#compatible" title="永久链接至标题">¶</a></h5>
<p>  “compatible”表示“兼容”，对于某个LED，内核中可能有A、B、C三个驱动都支持它，那可以这样写：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		led {   
		compatible = “A”, “B”, “C”;   
		};   
</pre></div>
</div>
<p>  内核启动时，就会为这个LED按这样的优先顺序为它找到驱动程序：A、B、C。</p>
<p>  根节点下也有compatible属性，用来选择哪一个“machine desc”：一个内核可以支持machine A，也支持machine B，内核启动后会根据根节点的compatible属性找到对应的machine desc结构体，执行其中的初始化函数。</p>
<p>  compatible的值，建议取这样的形式：”manufacturer,model”，即“厂家名,模块名”。</p>
<p>  <font color="# dd0000">注意：</font>machine desc的意思就是“机器描述”，学到内核启动流程时才涉及。</p>
</div>
<div class="section" id="model">
<h5>model<a class="headerlink" href="#model" title="永久链接至标题">¶</a></h5>
<p>  model属性与compatible属性有些类似，但是有差别。</p>
<p>  compatible属性是一个字符串列表，表示可以你的硬件兼容A、B、C等驱动；</p>
<p>  model用来准确地定义这个硬件是什么。</p>
<p>  比如根节点中可以这样写：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="o">/</span> <span class="p">{</span>   
			<span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;samsung,smdk2440&quot;</span><span class="p">,</span> <span class="s">&quot;samsung,mini2440&quot;</span><span class="p">;</span>   
			<span class="n">model</span> <span class="o">=</span> <span class="s">&quot;jz2440_v3&quot;</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
<p>  它表示这个单板，可以兼容内核中的“smdk2440”，也兼容“mini2440”。</p>
<p>  从compatible属性中可以知道它兼容哪些板，但是它到底是什么板？用model属性来明确。</p>
</div>
<div class="section" id="status">
<h5>status<a class="headerlink" href="#status" title="永久链接至标题">¶</a></h5>
<p>  dtsi文件中定义了很多设备，但是在你的板子上某些设备是没有的。这时你可以给这个设备节点添加一个status属性，设置为“disabled”：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="o">&amp;</span><span class="n">uart1</span> <span class="p">{</span>   
		     <span class="n">status</span> <span class="o">=</span> <span class="s">&quot;disabled&quot;</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_100.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_100.png" />
&lt;800px&gt;</p>
</div>
<div class="section" id="reg">
<h5>reg<a class="headerlink" href="#reg" title="永久链接至标题">¶</a></h5>
<p>  <font color="# dd0000">reg的本意是register，用来表示寄</font>存器地址。</p>
<p>  但是在设备树里，它可以用来描述一段空间。反正对于ARM系统，寄存器和内存是统一编址的，即访问寄存器时用某块地址，访问内存时用某块地址，在访问方法上没有区别。</p>
<p>  reg属性的值，是一系列的“address  size”，用多少个32位的数来表示address和size，由其父节点的# address-cells、#size-cells决定。</p>
<p>  示例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		/dts-v1/;   
		/ {   
				# address-cells = &lt;1&gt;;   
				# size-cells = &lt;1&gt;;   
				memory {   
				reg = &lt;0x80000000 0x20000000&gt;;   
			};   
		};   
</pre></div>
</div>
</div>
<div class="section" id="name">
<h5>name(过时了，建议不用)<a class="headerlink" href="#name" title="永久链接至标题">¶</a></h5>
<p>  它的值是字符串，用来表示节点的名字。在跟platform_driver匹配时，优先级最低。</p>
<p>  compatible属性在匹配过程中，优先级最高。</p>
</div>
<div class="section" id="device-type">
<h5>device_type(过时了，建议不用)<a class="headerlink" href="#device-type" title="永久链接至标题">¶</a></h5>
<p>  它的值是字符串，用来表示节点的类型。在跟platform_driver匹配时，优先级为中。</p>
<p>  compatible属性在匹配过程中，优先级最高。</p>
</div>
</div>
<div class="section" id="id91">
<h4>常用的节点(node)<a class="headerlink" href="#id91" title="永久链接至标题">¶</a></h4>
<div class="section" id="id92">
<h5>根节点<a class="headerlink" href="#id92" title="永久链接至标题">¶</a></h5>
<p>  dts文件中必须有一个根节点：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	/dts-v1/;   
	/ {   
			model = &quot;SMDK24440&quot;;   
			compatible = &quot;samsung,smdk2440&quot;;   
   
			# address-cells = &lt;1&gt;;   
			# size-cells = &lt;1&gt;;   
	};   
   
</pre></div>
</div>
<p>  根节点中必须有这些属性：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1"># address-cells // 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)   </span>
		<span class="c1"># size-cells   // 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)   </span>
		compatible   // 定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备   
		         // 即这个板子兼容哪些平台   
		         // uImage : smdk2410 smdk2440 <span class="nv">mini2440</span>    <span class="o">==</span>&gt; machine_desc         
		               
		model      // 咱这个板子是什么   
		         // 比如有2款板子配置基本一致, 它们的compatible是一样的   
		         // 那么就通过model来分辨这2款板子   
</pre></div>
</div>
</div>
<div class="section" id="cpu">
<h5>CPU节点<a class="headerlink" href="#cpu" title="永久链接至标题">¶</a></h5>
<p>  一般不需要我们设置，在dtsi文件中都定义好了：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		cpus {   
				# address-cells = &lt;1&gt;;   
				# size-cells = &lt;0&gt;;   
		   
				cpu0: cpu@0 {   
				   .......   
		      }   
		};   
</pre></div>
</div>
</div>
<div class="section" id="memory">
<h5>memory节点<a class="headerlink" href="#memory" title="永久链接至标题">¶</a></h5>
<p>  芯片厂家不可能事先确定你的板子使用多大的内存，所以memory节点需要板厂设置，比如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">memory</span> <span class="p">{</span>   
			<span class="n">reg</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x80000000</span> <span class="mh">0x20000000</span><span class="o">&gt;</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
</div>
<div class="section" id="chosen">
<h5>chosen节点<a class="headerlink" href="#chosen" title="永久链接至标题">¶</a></h5>
<p>  我们可以通过设备树文件给内核传入一些参数，这要在chosen节点中设置bootargs属性：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">chosen</span> <span class="p">{</span>   
			<span class="n">bootargs</span> <span class="o">=</span> <span class="s">&quot;noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200&quot;</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id93">
<h3>编译、更换设备树<a class="headerlink" href="#id93" title="永久链接至标题">¶</a></h3>
<p>  我们一般不会从零写dts文件，而是修改。程序员水平有高有低，改得对不对？需要编译一下。并且内核直接使用dts文件的话，就太低效了，它也需要使用二进制格式的dtb文件。</p>
<div class="section" id="make">
<h4>在内核中直接make<a class="headerlink" href="#make" title="永久链接至标题">¶</a></h4>
<p>  设置ARCH、CROSS_COMPILE、PATH这三个环境变量后，进入ubuntu上板子内核源码的目录，执行如下命令即可编译dtb文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span>  <span class="n">dtbs</span>  <span class="n">V</span><span class="o">=</span><span class="mi">1</span>   
</pre></div>
</div>
<p>  这些操作步骤在各个开发板的高级用户使用手册，或是http://wiki.100ask.net中各个板子的页面里，都有说明。</p>
<p>  以野火的IMX6UL为例，可以看到如下输出：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span> <span class="p">;</span>   
		<span class="n">arm</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnueabihf</span><span class="o">-</span><span class="n">gcc</span> <span class="o">-</span><span class="n">E</span>   
		  <span class="o">-</span><span class="n">Wp</span><span class="p">,</span><span class="o">-</span><span class="n">MD</span><span class="p">,</span><span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="p">.</span><span class="n">imx6ull</span><span class="o">-</span><span class="mi">14</span><span class="n">x14</span><span class="o">-</span><span class="n">ebf</span><span class="o">-</span><span class="n">mini</span><span class="p">.</span><span class="n">dtb</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">pre</span><span class="p">.</span><span class="n">tmp</span>   
		  <span class="o">-</span><span class="n">nostdinc</span>   
		  <span class="o">-</span><span class="n">I</span><span class="p">.</span><span class="o">/</span><span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span>   
		  <span class="o">-</span><span class="n">I</span><span class="p">.</span><span class="o">/</span><span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">include</span>   
		  <span class="o">-</span><span class="n">I</span><span class="p">.</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">of</span><span class="o">/</span><span class="n">testcase</span><span class="o">-</span><span class="n">data</span>   
		  <span class="o">-</span><span class="n">undef</span> <span class="o">-</span><span class="n">D__DTS__</span> <span class="o">-</span><span class="n">x</span> <span class="n">assembler</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">cpp</span>   
		  <span class="o">-</span><span class="n">o</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="p">.</span><span class="n">imx6ull</span><span class="o">-</span><span class="mi">14</span><span class="n">x14</span><span class="o">-</span><span class="n">ebf</span><span class="o">-</span><span class="n">mini</span><span class="p">.</span><span class="n">dtb</span><span class="p">.</span><span class="n">dts</span><span class="p">.</span><span class="n">tmp</span>   
		  <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">imx6ull</span><span class="o">-</span><span class="mi">14</span><span class="n">x14</span><span class="o">-</span><span class="n">ebf</span><span class="o">-</span><span class="n">mini</span><span class="p">.</span><span class="n">dts</span> <span class="p">;</span>   
		    
		<span class="p">.</span><span class="o">/</span><span class="n">scripts</span><span class="o">/</span><span class="n">dtc</span><span class="o">/</span><span class="n">dtc</span> <span class="o">-</span><span class="n">O</span> <span class="n">dtb</span>   
		  <span class="o">-</span><span class="n">o</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="n">imx6ull</span><span class="o">-</span><span class="mi">14</span><span class="n">x14</span><span class="o">-</span><span class="n">ebf</span><span class="o">-</span><span class="n">mini</span><span class="p">.</span><span class="n">dtb</span>   
		  <span class="o">-</span><span class="n">b</span> <span class="mi">0</span> <span class="o">-</span><span class="n">i</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span> <span class="o">-</span><span class="n">Wno</span><span class="o">-</span><span class="n">unit_address_vs_reg</span>    
		  <span class="o">-</span><span class="n">d</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="p">.</span><span class="n">imx6ull</span><span class="o">-</span><span class="mi">14</span><span class="n">x14</span><span class="o">-</span><span class="n">ebf</span><span class="o">-</span><span class="n">mini</span><span class="p">.</span><span class="n">dtb</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">dtc</span><span class="p">.</span><span class="n">tmp</span>   
		  <span class="n">arch</span><span class="o">/</span><span class="n">arm</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span><span class="p">.</span><span class="n">imx6ull</span><span class="o">-</span><span class="mi">14</span><span class="n">x14</span><span class="o">-</span><span class="n">ebf</span><span class="o">-</span><span class="n">mini</span><span class="p">.</span><span class="n">dtb</span><span class="p">.</span><span class="n">dts</span><span class="p">.</span><span class="n">tmp</span> <span class="p">;</span>   
</pre></div>
</div>
<p>  它首先用arm-linux-gnueabihf-gcc预处理dts文件，把其中的.h头文件包含进来，把宏展开。</p>
<p>  然后使用scripts/dtc/dtc生成dtb文件。</p>
<p>  可见，dts文件之所以支持“# include”语法，是因为arm-linux-gnueabihf-gcc帮忙。</p>
<p>  如果只用dtc工具，它是不支持”# include”语法的，只支持“/include”语法。</p>
</div>
<div class="section" id="id94">
<h4>手工编译<a class="headerlink" href="#id94" title="永久链接至标题">¶</a></h4>
<p>  除非你对设备树比较了解，否则不建议手工使用dtc工具直接编译。</p>
<p>  内核目录下scripts/dtc/dtc是设备树的编译工具，直接使用它的话，包含其他文件时不能使用“# include”，而必须使用“/incldue”。</p>
<p>  编译、反编译的示例命令如下，“-I”指定输入格式，“-O”指定输出格式，“-o”指定输出文件：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts  // 编译dts为dtb   
		./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb  // 反编译dtb为dts   
</pre></div>
</div>
</div>
<div class="section" id="id95">
<h4>给开发板更换设备树文件<a class="headerlink" href="#id95" title="永久链接至标题">¶</a></h4>
<p>  怎么给各个单板编译出设备树文件，它们的设备树文件是哪一个？</p>
<p>  这些操作步骤在各个开发板的高级用户使用手册，或是[](http://wiki.100ask.net http://wiki.100ask.net)中各个板子的页面里，都有说明。</p>
<p>  基本方法都是：设置ARCH、CROSS_COMPILE、PATH这三个环境变量后，在内核源码目录中执行：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	make  dtbs   
</pre></div>
</div>
<div class="section" id="ask-am335x">
<h5>对于100ask-am335x 单板<a class="headerlink" href="#ask-am335x" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/100ask-am335x.dtb</p>
<p>  要更换板子上的设备树文件，启动板子后，更换这个文件：/boot/mx6ull-14x14-ebf.dtb</p>
</div>
<div class="section" id="firefly-rk3288">
<h5>对于firefly-rk3288<a class="headerlink" href="#firefly-rk3288" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/rk3288-firefly.dtb</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/rk3288-firefly.dtb</p>
</div>
<div class="section" id="fireflyroc-rk3399-pc">
<h5>对于firefly的roc-rk3399-pc<a class="headerlink" href="#fireflyroc-rk3399-pc" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm64/boot/dts/rk3399-roc-pc.dtb</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/ rk3399-roc-pc.dtb</p>
</div>
<div class="section" id="qemuimx6ull">
<h5>对于百问网使用QEMU模拟的IMX6ULL板子<a class="headerlink" href="#qemuimx6ull" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/100ask_imx6ul_qemu.dtb</p>
<p>  它是执行qemu时直接在命令行中指定设备树文件的，你可以打开脚本文件qemu-imx6ul-gui.sh找到dtb文件的位置，然后使用新编译出来的dtb去覆盖老文件。</p>
</div>
<div class="section" id="imx6ull-pro">
<h5>对于野火imx6ull-pro<a class="headerlink" href="#imx6ull-pro" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/imx6ull-14x14-ebf.dtb</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/imx6ull-14x14-ebf.dtb</p>
</div>
<div class="section" id="imx6ull-alpha">
<h5>对于正点原子imx6ull-alpha<a class="headerlink" href="#imx6ull-alpha" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/imx6ull-14x14-alpha.dtb</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/arch/arm/boot/dts/imx6ull-14x14-alpha.dtb</p>
</div>
</div>
<div class="section" id="id96">
<h4>板子启动后查看设备树<a class="headerlink" href="#id96" title="永久链接至标题">¶</a></h4>
<p>  板子启动后执行下面的命令：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1">#  ls /sys/firmware/   </span>
		devicetree  fdt   
</pre></div>
</div>
<p>  /sys/firmware/devicetree目录下是以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件。</p>
<p>  这些属性的值如果是字符串，可以使用cat命令把它打印出来；对于数值，可以用hexdump把它打印出来。</p>
<p>  还可以看到/sys/firmware/fdt文件，它就是dtb格式的设备树文件，可以把它复制出来放到ubuntu上，执行下面的命令反编译出来(-I dtb：输入格式是dtb，-O dts：输出格式是dts)：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="nb">cd</span>  板子所用的内核源码目录   
		./scripts/dtc/dtc  -I  dtb  -O  dts   /从板子上/复制出来的/fdt  -o   tmp.dts   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id97">
<h3>内核对设备树的处理<a class="headerlink" href="#id97" title="永久链接至标题">¶</a></h3>
<p>  从源代码文件dts文件开始，设备树的处理过程为：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_101.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_101.png" />
&lt;600px&gt;</p>
<p>    ① dts在PC机上被编译为dtb文件；</p>
<p>    ② u-boot把dtb文件传给内核；</p>
<p>    ③ 内核解析dtb文件，把每一个节点都转换为device_node结构体；</p>
<p>    ④ 对于某些device_node结构体，会被转换为platform_device结构体。</p>
<div class="section" id="dtbdevice-node">
<h4>dtb中每一个节点都被转换为device_node结构体<a class="headerlink" href="#dtbdevice-node" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_102.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_102.png" />
&lt;600px&gt;
  根节点被保存在全局变量of_root中，从of_root开始可以访问到任意节点。</p>
</div>
<div class="section" id="id98">
<h4>哪些设备树节点会被转换为platform_device<a class="headerlink" href="#id98" title="永久链接至标题">¶</a></h4>
<p>  A. 根节点下含有compatile属性的<font color="# dd0000">子节点</font></p>
<p>  B. 含有特定compatile属性的节点的<font color="# dd0000">子节点</font></p>
<p>    如果一个节点的compatile属性，它的值是这4者之一：”simple-bus”,”simple-mfd”,”isa”,”arm,amba-bus”,</p>
<p>    那么它的<font color="# dd0000">子结点</font>(需含compatile属性)也可以转换为platform_device。</p>
<p>  C. 总线I2C、SPI节点下的子节点：<font color="# dd0000">不转换</font>为platform_device</p>
<p>    某个总线下到子节点，应该交给对应的总线驱动程序来处理, 它们不应该被转换为platform_device。</p>
<p>    比如以下的节点中：</p>
<p>      /mytest会被转换为platform_device, 因为它兼容”simple-bus”;</p>
<p>      它的子节点/mytest/mytest&#64;0 也会被转换为platform_device</p>
<p>      /i2c节点一般表示i2c控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;</p>
<p>      /i2c/at24c02节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个i2c_client。</p>
<p>      类似的也有/spi节点, 它一般也是用来表示SPI控制器, 它会被转换为platform_device, 在内核中有对应的platform_driver;</p>
<p>  /spi/flash&#64;0节点不会被转换为platform_device, 它被如何处理完全由父节点的platform_driver决定, 一般是被创建为一个spi_device。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>			/ {   
				  mytest {   
					  compatile = &quot;mytest&quot;, &quot;simple-bus&quot;;   
					  mytest@0 {   
							compatile = &quot;mytest_0&quot;;   
					  };   
				  };   
				    
				  i2c {   
					  compatile = &quot;samsung,i2c&quot;;   
					  at24c02 {   
							compatile = &quot;at24c02&quot;;                   
					  };   
				  };   
			   
				  spi {   
					  compatile = &quot;samsung,spi&quot;;             
					  flash@0 {   
							compatible = &quot;winbond,w25q32dw&quot;;   
							spi-max-frequency = &lt;25000000&gt;;   
							reg = &lt;0&gt;;   
						  };   
				  };   
			  };   
</pre></div>
</div>
</div>
<div class="section" id="id99">
<h4>怎么转换为platform_device<a class="headerlink" href="#id99" title="永久链接至标题">¶</a></h4>
<p>  内核处理设备树的函数调用过程，这里不去分析；我们只需要得到如下结论：</p>
<p>    A. platform_device中含有resource数组, 它来自device_node的reg, interrupts属性;</p>
<p>    B. platform_device.dev.of_node指向device_node, 可以通过它获得其他属性</p>
</div>
</div>
<div class="section" id="platform-deviceplatform-driver">
<h3>platform_device如何与platform_driver配对<a class="headerlink" href="#platform-deviceplatform-driver" title="永久链接至标题">¶</a></h3>
<p>  从设备树转换得来的platform_device会被注册进内核里，以后当我们每注册一个platform_driver时，它们就会两两确定能否配对，如果能配对成功就调用platform_driver的probe函数。</p>
<p>  套路是一样的。</p>
<p>  我们需要将前面讲过的“匹配规则”再完善一下：</p>
<p>  先贴源码：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_103.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_103.png" />
&lt;600px&gt;</p>
<div class="section" id="driver">
<h4>最先比较：是否强制选择某个driver<a class="headerlink" href="#driver" title="永久链接至标题">¶</a></h4>
<p>  比较platform_device. driver_override和platform_driver.driver.name</p>
<p>  可以设置platform_device的driver_override，强制选择某个platform_driver。</p>
</div>
<div class="section" id="id100">
<h4>然后比较：设备树信息<a class="headerlink" href="#id100" title="永久链接至标题">¶</a></h4>
<p>  比较：platform_device. dev.of_node和platform_driver.driver.of_match_table。</p>
<p>  由设备树节点转换得来的platform_device中，含有一个结构体：of_node。</p>
<p>  它的类型如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_104.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_104.png" />
&lt;400px&gt;</p>
<p>  如果一个platform_driver支持设备树，它的platform_driver.driver.of_match_table是一个数组，类型如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_105.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_105.png" />
&lt;200px&gt;</p>
<p>  使用设备树信息来判断dev和drv是否配对时，</p>
<p>  <font color="# dd0000">首先</font>，如果of_match_table中含有compatible值，就跟dev的compatile属性比较，若一致则成功，否则返回失败；</p>
<p>  <font color="# dd0000">其次</font>，如果of_match_table中含有type值，就跟dev的device_type属性比较，若一致则成功，否则返回失败；</p>
<p>  <font color="# dd0000">最后</font>，如果of_match_table中含有name值，就跟dev的name属性比较，若一致则成功，否则返回失败。</p>
<p>  而设备树中建议不再使用devcie_type和name属性，所以基本上只使用设备节点的compatible属性来寻找匹配的platform_driver。</p>
</div>
<div class="section" id="platform-device-id">
<h4>接下来比较：platform_device_id<a class="headerlink" href="#platform-device-id" title="永久链接至标题">¶</a></h4>
<p>  比较platform_device. name和platform_driver.id_table[i].name，id_table中可能有多项。</p>
<p>  platform_driver.id_table是“platform_device_id”指针，表示该drv支持若干个device，它里面列出了各个device的{.name, .driver_data}，其中的“name”表示该drv支持的设备的名字，driver_data是些提供给该device的私有数据。</p>
</div>
<div class="section" id="id101">
<h4>最后比较：platform_device.name和platform_driver.driver.name<a class="headerlink" href="#id101" title="永久链接至标题">¶</a></h4>
<p>  platform_driver.id_table可能为空，</p>
<p>  这时可以根据platform_driver.driver.name来寻找同名的platform_device。</p>
</div>
<div class="section" id="id102">
<h4>一个图概括所有的配对过程<a class="headerlink" href="#id102" title="永久链接至标题">¶</a></h4>
<p>  概括出了这个图：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_106.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_106.png" />
&lt;1200px&gt;</p>
</div>
</div>
<div class="section" id="id103">
<h3>没有转换为platform_device的节点，如何使用<a class="headerlink" href="#id103" title="永久链接至标题">¶</a></h3>
<p>  任意驱动程序里，都可以直接访问设备树。</p>
<p>  你可以使用“11.7”节中介绍的函数找到节点，读出里面的值。</p>
</div>
<div class="section" id="id104">
<h3>内核里操作设备树的常用函数<a class="headerlink" href="#id104" title="永久链接至标题">¶</a></h3>
<p>  内核源码中include/linux/目录下有很多of开头的头文件，of表示“open firmware”即开放固件。</p>
<div class="section" id="id105">
<h4>内核中设备树相关的头文件介绍<a class="headerlink" href="#id105" title="永久链接至标题">¶</a></h4>
<p>  内核源码中include/linux/目录下有很多of开头的头文件，of表示“open firmware”即开放固件。</p>
<p>  设备树的处理过程是：dtb -&gt; device_node -&gt; platform_device</p>
<div class="section" id="dtb">
<h5>处理DTB<a class="headerlink" href="#dtb" title="永久链接至标题">¶</a></h5>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">of_fdt</span><span class="p">.</span><span class="n">h</span>         <span class="c1">// dtb文件的相关操作函数, 我们一般用不到,   </span>
		<span class="c1">// 因为dtb文件在内核中已经被转换为device_node树(它更易于使用)   </span>
</pre></div>
</div>
</div>
<div class="section" id="device-node">
<h5>处理device_node<a class="headerlink" href="#device-node" title="永久链接至标题">¶</a></h5>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">of</span><span class="p">.</span><span class="n">h</span>            <span class="c1">// 提供设备树的一般处理函数,   </span>
		<span class="c1">// 比如 of_property_read_u32(读取某个属性的u32值),   </span>
		<span class="c1">// of_get_child_count(获取某个device_node的子节点数)   </span>
		<span class="n">of_address</span><span class="p">.</span><span class="n">h</span>      <span class="c1">// 地址相关的函数,   </span>
		<span class="c1">// 比如 of_get_address(获得reg属性中的addr, size值)   </span>
		<span class="c1">// of_match_device (从matches数组中取出与当前设备最匹配的一项)   </span>
		<span class="n">of_dma</span><span class="p">.</span><span class="n">h</span>         <span class="c1">// 设备树中DMA相关属性的函数   </span>
		<span class="n">of_gpio</span><span class="p">.</span><span class="n">h</span>        <span class="c1">// GPIO相关的函数   </span>
		<span class="n">of_graph</span><span class="p">.</span><span class="n">h</span>       <span class="c1">// GPU相关驱动中用到的函数, 从设备树中获得GPU信息   </span>
		<span class="n">of_iommu</span><span class="p">.</span><span class="n">h</span>       <span class="c1">// 很少用到   </span>
		<span class="n">of_irq</span><span class="p">.</span><span class="n">h</span>         <span class="c1">// 中断相关的函数   </span>
		<span class="n">of_mdio</span><span class="p">.</span><span class="n">h</span>        <span class="c1">// MDIO (Ethernet PHY) API   </span>
		<span class="n">of_net</span><span class="p">.</span><span class="n">h</span>         <span class="c1">// OF helpers for network devices.   </span>
		<span class="n">of_pci</span><span class="p">.</span><span class="n">h</span>         <span class="c1">// PCI相关函数   </span>
		<span class="n">of_pdt</span><span class="p">.</span><span class="n">h</span>         <span class="c1">// 很少用到   </span>
		<span class="n">of_reserved_mem</span><span class="p">.</span><span class="n">h</span>  <span class="c1">// reserved_mem的相关函数   </span>
</pre></div>
</div>
</div>
<div class="section" id="id106">
<h5>处理 platform_device<a class="headerlink" href="#id106" title="永久链接至标题">¶</a></h5>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">of_platform</span><span class="p">.</span><span class="n">h</span>     <span class="c1">// 把device_node转换为platform_device时用到的函数,   </span>
		               <span class="c1">// 比如of_device_alloc(根据device_node分配设置platform_device),   </span>
		               <span class="c1">// of_find_device_by_node (根据device_node查找到platform_device),   </span>
		               <span class="c1">//   of_platform_bus_probe (处理device_node及它的子节点)   </span>
		<span class="n">of_device</span><span class="p">.</span><span class="n">h</span>      <span class="c1">// 设备相关的函数, 比如 of_match_device   </span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id107">
<h4>platform_device相关的函数<a class="headerlink" href="#id107" title="永久链接至标题">¶</a></h4>
<p>  of_platform.h中声明了很多函数，但是作为驱动开发者，我们只使用其中的1、2个。其他的都是给内核自己使用的，内核使用它们来处理设备树，转换得到platform_device。</p>
<div class="section" id="of-find-device-by-node">
<h5>of_find_device_by_node<a class="headerlink" href="#of-find-device-by-node" title="永久链接至标题">¶</a></h5>
<p>  函数原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">extern</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="nf">of_find_device_by_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>   
</pre></div>
</div>
<p>  设备树中的每一个节点，在内核里都有一个device_node；你可以使用device_node去找到对应的platform_device。</p>
</div>
<div class="section" id="platform-get-resource">
<h5>platform_get_resource<a class="headerlink" href="#platform-get-resource" title="永久链接至标题">¶</a></h5>
<p>  这个函数跟设备树没什么关系，但是设备树中的节点被转换为platform_device后，设备树中的reg属性、interrupts属性也会被转换为“resource”。</p>
<p>  这时，你可以使用这个函数取出这些资源。</p>
<p>  函数原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>			<span class="cm">/**   </span>
<span class="cm">			 * platform_get_resource - get a resource for a device   </span>
<span class="cm">			 * @dev: platform device   </span>
<span class="cm">			 * @type: resource type   // 取哪类资源？IORESOURCE_MEM、IORESOURCE_REG   </span>
<span class="cm">			*                 // IORESOURCE_IRQ等   </span>
<span class="cm">			 * @num: resource index  // 这类资源中的哪一个？   </span>
<span class="cm">			 */</span>   
			<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="nf">platform_get_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>   
							      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>   
</pre></div>
</div>
<p>  对于设备树节点中的reg属性，它属性IORESOURCE_MEM类型的资源；</p>
<p>  对于设备树节点中的interrupts属性，它属性IORESOURCE_IRQ类型的资源。</p>
</div>
</div>
<div class="section" id="id108">
<h4>有些节点不会生成platform_device，怎么访问它们<a class="headerlink" href="#id108" title="永久链接至标题">¶</a></h4>
<p>  内核会把dtb文件解析出一系列的device_node结构体，我们可以直接访问这些device_node。</p>
<p>  内核源码incldue/linux/of.h中声明了device_node和属性property的操作函数，device_node和property的结构体定义如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_102.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_102.png" />
&lt;800px&gt;</p>
<div class="section" id="id109">
<h5>找到节点<a class="headerlink" href="#id109" title="永久链接至标题">¶</a></h5>
<p>  a. of_find_node_by</p>
<p>    根据路径找到节点，比如“/”就对应根节点，“/memory”对应memory节点。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>   
</pre></div>
</div>
<p>  b. of_find_node_by_name</p>
<p>    根据名字找到节点，节点如果定义了name属性，那我们可以根据名字找到它。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		 <span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>   
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。</p>
<p>    但是在设备树的官方规范中不建议使用“name”属性，所以这函数也不建议使用。</p>
<p>  c. of_find_node_by_type</p>
<p>    根据类型找到节点，节点如果定义了device_type属性，那我们可以根据类型找到它。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		 <span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>   
		 	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。</p>
<p>    但是在设备树的官方规范中不建议使用“device_type”属性，所以这函数也不建议使用。</p>
<p>  d. of_find_compatible_node</p>
<p>    根据compatible找到节点，节点如果定义了compatible属性，那我们可以根据compatible属性找到它。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_compatible_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>   
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compat</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。</p>
<p>    参数compat是一个字符串，用来指定compatible属性的值；</p>
<p>    参数type是一个字符串，用来指定device_type属性的值，可以传入NULL。</p>
<p>  e. of_find_node_by_phandle</p>
<p>    根据phandle找到节点。</p>
<p>    dts文件被编译为dtb文件时，每一个节点都有一个数字ID，这些数字ID彼此不同。可以使用数字ID来找到device_node。这些数字ID就是phandle。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_phandle</span><span class="p">(</span><span class="n">phandle</span> <span class="n">handle</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。</p>
<p>  f. of_get_parent</p>
<p>    找到device_node的父节点。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_parent</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。</p>
<p>  g. of_get_next_parent</p>
<p>    这个函数名比较奇怪，怎么可能有“next parent”？</p>
<p>    它实际上也是找到device_node的父节点，跟of_get_parent的返回结果是一样的。</p>
<p>    差别在于它多调用下列函数，把node节点的引用计数减少了1。这意味着调用of_get_next_parent之后，你不再需要调用of_node_put释放node节点。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">of_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>   
</pre></div>
</div>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_next_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数from表示从哪一个节点开始寻找，传入NULL表示从根节点开始寻找。</p>
<p>  h. of_get_next_child</p>
<p>    取出下一个子节点。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>			<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_next_child</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>   
								    <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数node表示父节点；</p>
<p>    prev表示上一个子节点，设为NULL时表示想找到第1个子节点。</p>
<p>    不断调用of_get_next_child时，不断更新pre参数，就可以得到所有的子节点。</p>
<p>  i. of_get_next_available_child</p>
<p>    取出下一个“可用”的子节点，有些节点的status是“disabled”，那就会跳过这些节点。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		 <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_next_available_child</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>   
		 	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数node表示父节点；</p>
<p>    prev表示上一个子节点，设为NULL时表示想找到第1个子节点。</p>
<p>  j. of_get_child_by_name</p>
<p>    根据名字取出子节点。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>			<span class="k">extern</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_child_by_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>   
								<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数node表示父节点；</p>
<p>    name表示子节点的名字。</p>
</div>
<div class="section" id="id110">
<h5>找到属性<a class="headerlink" href="#id110" title="永久链接至标题">¶</a></h5>
<p>  内核源码incldue/linux/of.h中声明了device_node的操作函数，当然也包括属性的操作函数。</p>
<p>  a. of_find_property</p>
<p>    找到节点中的属性。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">extern</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="nf">of_find_property</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
							 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>   
							 <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">);</span>   
</pre></div>
</div>
<p>    参数np表示节点，我们要在这个节点中找到名为name的属性。</p>
<p>    lenp用来保存这个属性的长度，即它的值的长度。</p>
<p>    在设备树中，节点大概是这样：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	xxx_node {   
	   xxx_pp_name = “hello”;   
	};   
</pre></div>
</div>
<p>    上述节点中，“xxx_pp_name”就是属性的名字，值的长度是6。</p>
</div>
<div class="section" id="id111">
<h5>获取属性的值<a class="headerlink" href="#id111" title="永久链接至标题">¶</a></h5>
<p>  a. of_get_property</p>
<p>    根据名字找到节点的属性，并且返回它的值。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="cm">/*   </span>
<span class="cm">		 * Find a property with a given name for a given node   </span>
<span class="cm">		 * and return the value.   </span>
<span class="cm">		 */</span>   
		<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">of_get_property</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>   
					   <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>   
</pre></div>
</div>
<p>    参数np表示节点，我们要在这个节点中找到名为name的属性，然后返回它的值。</p>
<p>    lenp用来保存这个属性的长度，即它的值的长度。</p>
<p>  b. of_property_count_elems_of_size</p>
<p>    根据名字找到节点的属性，确定它的值有多少个元素(elem)。</p>
<p>    函数原型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="cm">/* of_property_count_elems_of_size - Count the number of elements in a property   </span>
<span class="cm">		 *   </span>
<span class="cm">		 * @np:		device node from which the property value is to be read.   </span>
<span class="cm">		 * @propname:	name of the property to be searched.   </span>
<span class="cm">		 * @elem_size:	size of the individual element   </span>
<span class="cm">		 *   </span>
<span class="cm">		 * Search for a property in a device node and count the number of elements of   </span>
<span class="cm">		 * size elem_size in it. Returns number of elements on sucess, -EINVAL if the   </span>
<span class="cm">		 * property does not exist or its length does not match a multiple of elem_size   </span>
<span class="cm">		 * and -ENODATA if the property does not have a value.   </span>
<span class="cm">		 */</span>   
		<span class="kt">int</span> <span class="n">of_property_count_elems_of_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">elem_size</span><span class="p">)</span>   
</pre></div>
</div>
<p>    参数np表示节点，我们要在这个节点中找到名为propname的属性，然后返回下列结果：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">return</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">/</span> <span class="n">elem_size</span><span class="p">;</span>   
</pre></div>
</div>
<p>    在设备树中，节点大概是这样：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">xxx_node</span> <span class="p">{</span>   
		   <span class="n">xxx_pp_name</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x50000000</span> <span class="mi">1024</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="mh">0x60000000</span>  <span class="mi">2048</span><span class="o">&gt;</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
<p>    调用of_property_count_elems_of_size(np, “xxx_pp_name”, 8)时，返回值是2；</p>
<p>    调用of_property_count_elems_of_size(np, “xxx_pp_name”, 4)时，返回值是4。</p>
<p>  c. 读整数u32/u64</p>
<p>    函数原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">of_property_read_u32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
						      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>   
						      <span class="n">u32</span> <span class="o">*</span><span class="n">out_value</span><span class="p">);</span>   
   
		<span class="k">extern</span> <span class="kt">int</span> <span class="nf">of_property_read_u64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
	 				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">out_value</span><span class="p">);</span>   
</pre></div>
</div>
<p>    在设备树中，节点大概是这样：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	<span class="n">xxx_node</span> <span class="p">{</span>   
	   <span class="n">name1</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x50000000</span><span class="o">&gt;</span><span class="p">;</span>   
	   <span class="n">name2</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x50000000</span>  <span class="mh">0x60000000</span><span class="o">&gt;</span><span class="p">;</span>   
	<span class="p">};</span>   
</pre></div>
</div>
<p>    调用of_property_read_u32 (np, “name1”, &amp;val)时，val将得到值0x50000000；</p>
<p>    调用of_property_read_u64 (np, “name2”, &amp;val)时，val将得到值0x0x6000000050000000。</p>
<p>  d. 读某个整数u32/u64</p>
<p>    函数原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">extern</span> <span class="kt">int</span> <span class="nf">of_property_read_u32_index</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
						      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>   
						      <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out_value</span><span class="p">);</span>   
</pre></div>
</div>
<p>    在设备树中，节点大概是这样：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">xxx_node</span> <span class="p">{</span>   
		   <span class="n">name2</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x50000000</span>  <span class="mh">0x60000000</span><span class="o">&gt;</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
<p>    调用of_property_read_u32 (np, “name2”, 1, &amp;val)时，val将得到值0x0x60000000。</p>
<p>  e. 读数组</p>
<p>    函数原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="kt">int</span> <span class="nf">of_property_read_variable_u8_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
							<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span>   
							<span class="kt">size_t</span> <span class="n">sz_min</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz_max</span><span class="p">);</span>   
		   
		<span class="kt">int</span> <span class="nf">of_property_read_variable_u16_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
							<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span>   
							<span class="kt">size_t</span> <span class="n">sz_min</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz_max</span><span class="p">);</span>   
		   
		<span class="kt">int</span> <span class="nf">of_property_read_variable_u32_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span>   
					      <span class="kt">size_t</span> <span class="n">sz_min</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz_max</span><span class="p">);</span>   
		   
		<span class="kt">int</span> <span class="nf">of_property_read_variable_u64_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>   
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span>   
					      <span class="kt">size_t</span> <span class="n">sz_min</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz_max</span><span class="p">);</span>   
</pre></div>
</div>
<p>    在设备树中，节点大概是这样：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="n">xxx_node</span> <span class="p">{</span>   
		   <span class="n">name2</span> <span class="o">=</span> <span class="o">&lt;</span><span class="mh">0x50000012</span>  <span class="mh">0x60000034</span><span class="o">&gt;</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
<p>  上述例子中属性name2的值，长度为8。</p>
<p>  调用of_property_read_variable_u8_array (np, “name2”, out_values, 1, 10)时，out_values中将会保存这8个字节： 0x12,0x00,0x00,0x50,0x34,0x00,0x00,0x60。</p>
<p>  调用of_property_read_variable_u16_array (np, “name2”, out_values, 1, 10)时，out_values中将会保存这4个16位数值： 0x0012, 0x5000,0x0034,0x6000。</p>
<p>  总之，这些函数要么能取到全部的数值，要么一个数值都取不到；</p>
<p>  如果值的长度在sz_min和sz_max之间，就返回<font color="# dd0000">全部的数值</font>；否则一个数值都不返回。</p>
<p>  f. 读字符串</p>
<p>  函数原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		 <span class="kt">int</span> <span class="nf">of_property_read_string</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>   
		 				<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">out_string</span><span class="p">);</span>   
</pre></div>
</div>
<p>    返回节点np的属性(名为propname)的值，(*out_string)指向这个值，把它当作字符串。</p>
</div>
</div>
</div>
<div class="section" id="id112">
<h3>怎么修改设备树文件<a class="headerlink" href="#id112" title="永久链接至标题">¶</a></h3>
<p>  一个写得好的驱动程序, 它会尽量确定所用资源。</p>
<p>  只把不能确定的资源留给设备树, 让设备树来指定。</p>
<p>  根据原理图确定”驱动程序无法确定的硬件资源”, 再在设备树文件中填写对应内容。</p>
<p>  那么, 所填写内容的格式是什么?</p>
<div class="section" id="id113">
<h4>使用芯片厂家提供的工具<a class="headerlink" href="#id113" title="永久链接至标题">¶</a></h4>
<p>  有些芯片，厂家提供了对应的设备树生成工具，可以选择某个引脚用于某些功能，就可以自动生成设备树节点。</p>
<p>  你再把这些节点复制到内核的设备树文件里即可。</p>
</div>
<div class="section" id="id114">
<h4>看绑定文档<a class="headerlink" href="#id114" title="永久链接至标题">¶</a></h4>
<p>  内核文档 Documentation/devicetree/bindings/</p>
<p>  做得好的厂家也会提供设备树的说明文档</p>
</div>
<div class="section" id="id115">
<h4>参考同类型单板的设备树文件<a class="headerlink" href="#id115" title="永久链接至标题">¶</a></h4>
</div>
<div class="section" id="id116">
<h4>网上搜索<a class="headerlink" href="#id116" title="永久链接至标题">¶</a></h4>
</div>
<div class="section" id="id117">
<h4>实在没办法时, 只能去研究驱动源码<a class="headerlink" href="#id117" title="永久链接至标题">¶</a></h4>
</div>
</div>
</div>
<div class="section" id="id118">
<h2>LED模板驱动程序的改造：设备树<a class="headerlink" href="#id118" title="永久链接至标题">¶</a></h2>
<div class="section" id="id119">
<h3>总结3种写驱动程序的方法<a class="headerlink" href="#id119" title="永久链接至标题">¶</a></h3>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_107.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_107.png" />
&lt;600px&gt;
  核心永远是file_operations结构体。</p>
<p>  上述三种方法，只是指定“硬件资源”的方式不一样。</p>
<p>  从上图可以知道，platform_device/platform_driver只是编程的技巧，不涉及驱动的核心。</p>
</div>
<div class="section" id="id120">
<h3>怎么使用设备树写驱动程序<a class="headerlink" href="#id120" title="永久链接至标题">¶</a></h3>
<div class="section" id="id121">
<h4>设备树节点要与platform_driver能匹配<a class="headerlink" href="#id121" title="永久链接至标题">¶</a></h4>
<p>  在我们的工作中，驱动要求设备树节点提供什么，我们就得按这要求去编写设备树。</p>
<p>  但是，匹配过程所要求的东西是固定的：</p>
<p>    ① 设备树要有compatible属性，它的值是一个字符串</p>
<p>    ② platform_driver中要有of_match_table，其中一项的.compatible成员设置为一个字符串</p>
<p>    ③ 上述2个字符串要一致。</p>
<p>    示例如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_108.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_108.png" />
&lt;800px&gt;</p>
</div>
<div class="section" id="id122">
<h4>设备树节点指定资源，platform_driver获得资源<a class="headerlink" href="#id122" title="永久链接至标题">¶</a></h4>
<p>  如果在设备树节点里使用reg属性，那么内核生成对应的platform_device时会用reg属性来设置IORESOURCE_MEM类型的资源。</p>
<p>  如果在设备树节点里使用interrupts属性，那么内核生成对应的platform_device时会用reg属性来设置IORESOURCE_IRQ类型的资源。对于interrupts属性，内核会检查它的有效性，所以不建议在设备树里使用该属性来表示其他资源。</p>
<p>  在我们的工作中，驱动要求设备树节点提供什么，我们就得按这要求去编写设备树。驱动程序中根据pin属性来确定引脚，那么我们就在设备树节点中添加pin属性。</p>
<p>  设备树节点中：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		# define GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))   
		100ask_led0 {   
		   compatible = “100ask,led”;   
		   pin = &lt;GROUP_PIN(5, 3)&gt;;   
		};   
</pre></div>
</div>
<p>  驱动程序中，可以从platform_device中得到device_node，再用of_property_read_u32得到属性的值：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>			struct  device_node* np = pdev-&gt;dev. of_node;   
			int led_pin;   
			int err = of_property_read_u32(np, “pin”, &amp;led_pin);   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id123">
<h3>开始编程<a class="headerlink" href="#id123" title="永久链接至标题">¶</a></h3>
<div class="section" id="id124">
<h4>修改设备树添加led设备节点<a class="headerlink" href="#id124" title="永久链接至标题">¶</a></h4>
<p>  在本实验中，需要添加的设备节点代码是一样的，你需要找到你的单板所用的设备树文件，在它的根节点下添加如下内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>			# define GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))   
			100ask_led@0 {   
				compatible = &quot;100as,leddrv&quot;;   
				pin = &lt;GROUP_PIN(3, 1)&gt;;   
			};   
   
			100ask_led@1 {   
				compatible = &quot;100as,leddrv&quot;;   
				pin = &lt;GROUP_PIN(5, 8)&gt;;   
			};   
</pre></div>
</div>
<div class="section" id="id125">
<h5>对于100ask-am335x 单板<a class="headerlink" href="#id125" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/100ask-am335x.dts</p>
<p>  修改、编译后得到arch/arm/boot/dts/100ask-am335x.dtb文件。</p>
<p>  要更换板子上的设备树文件，启动板子后，更换这个文件：/boot/mx6ull-14x14-ebf.dtb</p>
</div>
<div class="section" id="id126">
<h5>对于firefly-rk3288<a class="headerlink" href="#id126" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/rk3288-firefly.dts</p>
<p>  修改、编译后得到arch/arm/boot/dts/rk3288-firefly.dtb文件。</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/rk3288-firefly.dtb</p>
</div>
<div class="section" id="id127">
<h5>对于firefly的roc-rk3399-pc<a class="headerlink" href="#id127" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm64/boot/dts/rk3399-roc-pc.dts</p>
<p>  修改、编译后得到arch/arm64/boot/dts/rk3399-roc-pc.dtb文件。</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/ rk3399-roc-pc.dtb</p>
</div>
<div class="section" id="id128">
<h5>对于百问网使用QEMU模拟的IMX6ULL板子<a class="headerlink" href="#id128" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/100ask_imx6ul_qemu.dts</p>
<p>  修改、编译后得到arch/arm/boot/dts/100ask_imx6ul_qemu.dtb文件。</p>
<p>  它是执行qemu时直接在命令行中指定设备树文件的，你可以打开脚本文件qemu-imx6ul-gui.sh找到dtb文件的位置，然后使用新编译出来的dtb去覆盖老文件。</p>
</div>
<div class="section" id="id129">
<h5>对于野火imx6ull-pro<a class="headerlink" href="#id129" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/imx6ull-14x14-ebf.dts</p>
<p>  修改、编译后得到arch/arm/boot/dts/imx6ull-14x14-ebf.dtb文件。</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/imx6ull-14x14-ebf.dtb</p>
</div>
<div class="section" id="id130">
<h5>对于正点原子imx6ull-alpha<a class="headerlink" href="#id130" title="永久链接至标题">¶</a></h5>
<p>  设备树文件是：内核源码目录中arch/arm/boot/dts/imx6ull-14x14-alpha.dts</p>
<p>  修改、编译后得到arch/arm/boot/dts/imx6ull-14x14-alpha.dtb文件。</p>
<p>  对于这款板子，本教程中我们使用SD卡上的系统。</p>
<p>  要更换板上的设备树文件，你可以使用SD卡启动开发板后，更换这个文件：/boot/arch/arm/boot/dts/imx6ull-14x14-alpha.dtb</p>
</div>
</div>
<div class="section" id="id131">
<h4>修改platform_driver的源码<a class="headerlink" href="#id131" title="永久链接至标题">¶</a></h4>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="mi">01</span><span class="n">_all_series_quickstart</span>\<span class="mi">04</span><span class="n">_快速入门</span><span class="p">(</span><span class="n">正式开始</span><span class="p">)</span>\   
		<span class="mi">02</span><span class="n">_嵌入式Linux驱动开发基础知识</span>\<span class="n">source</span>\   
			<span class="mi">02</span><span class="n">_led_drv</span>\<span class="mi">05</span><span class="n">_led_drv_template_device_tree</span>
</pre></div>
</div>
<p>  关键代码在chip_demo_gpio.c，主要看里面的platform_driver，代码如下。</p>
<p>  第166行指定了of_match_table，它是用来跟设备树节点匹配的，如果设备树节点中有compatile属性，并且其值等于第157行的“100as,leddrv”，就会导致第162行的probe函数被调用。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">156</span> <span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ask100_leds</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">157</span>    <span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;100as,leddrv&quot;</span> <span class="p">},</span>   
		<span class="mi">158</span>    <span class="p">{</span> <span class="p">},</span>   
		<span class="mi">159</span> <span class="p">};</span>   
		<span class="mi">160</span>   
		<span class="mi">161</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">chip_demo_gpio_driver</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">162</span>    <span class="p">.</span><span class="n">probe</span>     <span class="o">=</span> <span class="n">chip_demo_gpio_probe</span><span class="p">,</span>   
		<span class="mi">163</span>    <span class="p">.</span><span class="n">remove</span>    <span class="o">=</span> <span class="n">chip_demo_gpio_remove</span><span class="p">,</span>   
		<span class="mi">164</span>    <span class="p">.</span><span class="n">driver</span>    <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">165</span>       <span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">&quot;100ask_led&quot;</span><span class="p">,</span>   
		<span class="mi">166</span>       <span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">ask100_leds</span><span class="p">,</span>   
		<span class="mi">167</span>    <span class="p">},</span>   
		<span class="mi">168</span> <span class="p">};</span>   
		<span class="mi">169</span>   
		<span class="mi">170</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">chip_demo_gpio_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
		<span class="mi">171</span> <span class="p">{</span>   
		<span class="mi">172</span>    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>   
		<span class="mi">173</span>   
		<span class="mi">174</span>    <span class="n">err</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip_demo_gpio_driver</span><span class="p">);</span>   
		<span class="mi">175</span>    <span class="n">register_led_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board_demo_led_opr</span><span class="p">);</span>   
		<span class="mi">176</span>   
		<span class="mi">177</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">178</span> <span class="p">}</span>   
		<span class="mi">179</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id132">
<h3>上机实验<a class="headerlink" href="#id132" title="永久链接至标题">¶</a></h3>
<p>  1．使用新的设备树dtb文件启动单板，查看/sys/firmware/devicetree/base下有无节点</p>
<p>  2. 查看/sys/devices/platform目录下有无对应的platform_device</p>
<p>  3. 加载驱动：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1">#  insmod  leddrv.ko   </span>
		<span class="c1">#  insmod  chip_demo_gpio.ko   </span>
</pre></div>
</div>
<p>  4. 测试驱动：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1">#  ./ledtest   /dev/100ask_led0  on   </span>
		<span class="c1">#  ./ledtest   /dev/100ask_led0  off   </span>
</pre></div>
</div>
</div>
<div class="section" id="id133">
<h3>调试技巧<a class="headerlink" href="#id133" title="永久链接至标题">¶</a></h3>
<p>  /sys目录下有很多内核、驱动的信息：</p>
<div class="section" id="id134">
<h4>设备树的信息<a class="headerlink" href="#id134" title="永久链接至标题">¶</a></h4>
<p>  以下目录对应设备树的根节点，可以从此进去找到自己定义的节点。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="nb">cd</span> /sys/firmware/devicetree/base/   
</pre></div>
</div>
<p>  节点是目录，属性是文件。</p>
<p>  属性值是字符串时，用cat命令可以打印出来；属性值是数值时，用hexdump命令可以打印出来。</p>
</div>
<div class="section" id="id135">
<h4>platform_device的信息<a class="headerlink" href="#id135" title="永久链接至标题">¶</a></h4>
<p>  以下目录含有注册进内核的所有platform_device：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		/sys/devices/platform   
</pre></div>
</div>
<p>  一个设备对应一个目录，进入某个目录后，如果它有“driver”子目录，就表示这个platform_device跟某个platform_driver配对了。</p>
<p>  比如下面的结果中，平台设备“ff8a0000.i2s”已经跟平台驱动“<font color="# dd0000">rockchip-i2s</font>”配对了：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		/sys/devices/platform/ff8a0000.i2s<span class="o">]</span><span class="c1">#  ls driver -ld   </span>
		lrwxrwxrwx   <span class="m">1</span> root    root          <span class="m">0</span> Jan <span class="m">18</span> <span class="m">16</span>:28 driver -&gt; ../../../bus/platform/drivers/rockchip-i2s   
</pre></div>
</div>
</div>
<div class="section" id="id136">
<h4>platform_driver的信息<a class="headerlink" href="#id136" title="永久链接至标题">¶</a></h4>
<p>  以下目录含有注册进内核的所有platform_driver：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		/sys/bus/platform/drivers   
</pre></div>
</div>
<p>  一个driver对应一个目录，进入某个目录后，如果它有配对的设备，可以直接看到。</p>
<p>  比如下面的结果中，平台驱动“<font color="# dd0000">rockchip-i2s</font>”跟2个平台设备“平台设备“ff890000.i2s”、“ff8a0000.i2s”配对了：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_109.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_109.png" />
&lt;600px&gt;</p>
<p>  <font color="# dd0000">注意：</font>一个平台设备只能配对一个平台驱动，一个平台驱动可以配对多个平台设备。</p>
</div>
</div>
<div class="section" id="id137">
<h3>课后作业<a class="headerlink" href="#id137" title="永久链接至标题">¶</a></h3>
<p>  请仿照本节提供的程序(位于05_led_drv_template_device_tree目录)，改造你所用的单板的LED驱动程序。</p>
</div>
</div>
<div class="section" id="id138">
<h2>APP怎么读取按键值<a class="headerlink" href="#id138" title="永久链接至标题">¶</a></h2>
<p>  APP读取按键值，需要有按键驱动程序。</p>
<p>  <font color="# dd0000">为什么要讲按键驱动程序？</font></p>
<p>  APP去读按键的方法有4种：</p>
<p>    ① 查询方式</p>
<p>    ② 休眠-唤醒方式</p>
<p>    ③ poll方式</p>
<p>    ④ 异步通知方式</p>
<p>      通过这4种方式的学习，我们可以掌握如下知识：</p>
<p>        ① 驱动的基本技能：中断、休眠、唤醒、poll等机制。</p>
<p>          这些基本技能是驱动开发的基础，其他大型驱动复杂的地方是它的框架及设计思想，但是基本技术就这些。</p>
<p>        ② APP开发的基本技能：阻塞 、非阻塞、休眠、poll、异步通知。</p>
<div class="section" id="id139">
<h3>妈妈怎么知道孩子醒了<a class="headerlink" href="#id139" title="永久链接至标题">¶</a></h3>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_110.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_110.png" />
&lt;400px&gt;</p>
<p>  妈妈怎么知道卧室里小孩醒了？</p>
<p>    ① 时时进房间看一下：<font color="# dd0000">查询方式</font></p>
<p>      简单，但是累</p>
<p>    ② 进去房间陪小孩一起睡觉，小孩醒了会吵醒她：<font color="# dd0000">休眠-唤醒</font></p>
<p>      不累，但是妈妈干不了活了</p>
<p>    ③ 妈妈要干很多活，但是可以陪小孩睡一会，定个闹钟：<font color="# dd0000">poll方式</font></p>
<p>      要浪费点时间，但是可以继续干活。</p>
<p>      妈妈要么是被小孩吵醒，要么是被闹钟吵醒。</p>
<p>    ④ 妈妈在客厅干活，小孩醒了他会自己走出房门告诉妈妈：<font color="# dd0000">异步通知</font></p>
<p>      妈妈、小孩互不耽误。</p>
<p>  这4种方法没有优劣之分，在不同的场合使用不同的方法。</p>
</div>
<div class="section" id="app4">
<h3>APP读取按键的4种方法<a class="headerlink" href="#app4" title="永久链接至标题">¶</a></h3>
<p>  跟上述生活场景类似，APP去读取按键也有4种方法：</p>
<p>    ① 查询方式</p>
<p>    ② 休眠-唤醒方式</p>
<p>    ③ poll方式</p>
<p>    ④ 异步通知方式</p>
<p>  第2、3、4种方法，都涉及中断服务程序。中断，就像小孩醒了会哭闹一样，中断不经意间到来，它会做某些事情：唤醒APP、向APP发信号。</p>
<p>  所以，在按键驱动程序中，中断是核心。</p>
<p>  实际上，中断无论是在单片机还是在Linux中都很重要。在Linux中，中断的知识还涉及进程、线程等。</p>
<div class="section" id="id140">
<h4>查询方式<a class="headerlink" href="#id140" title="永久链接至标题">¶</a></h4>
<p>  这种方法最简单：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_111.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_111.png" />
&lt;400px&gt;</p>
<p>  驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read函数。APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚。APP调用read时，导致驱动中对应的read函数被调用，它读取寄存器，把引脚状态直接返回给APP。</p>
</div>
<div class="section" id="id141">
<h4>休眠-唤醒方式<a class="headerlink" href="#id141" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_112.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_112.png" />
&lt;600px&gt;
  驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read函数。</p>
<p>  APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。</p>
<p>  APP调用read时，导致驱动中对应的read函数被调用，如果有按键数据则直接返回给APP；否则APP在内核态休眠。</p>
<p>  当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的APP。</p>
<p>  APP被唤醒后继续在内核态运行，即继续执行驱动代码，把按键数据返回给APP(的用户空间)。</p>
</div>
<div class="section" id="poll">
<h4>poll方式<a class="headerlink" href="#poll" title="永久链接至标题">¶</a></h4>
<p>  上面的休眠-唤醒方式有个缺点：如果用户一直没操作按键，那么APP就会永远休眠。</p>
<p>  我们可以给APP定个闹钟，这就是poll方式。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_113.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_113.png" />
&lt;800px&gt;</p>
<p>  驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read,poll函数。</p>
<p>  APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。</p>
<p>  APP调用poll或select函数，意图是“查询”是否有数据，这2个函数都可以指定一个超时时间，即在这段时间内没有数据的话就返回错误。这会导致驱动中对应的poll函数被调用，如果有按键数据则直接返回给APP；否则APP在内核态休眠一段时间。</p>
<p>  当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的APP。</p>
<p>  如果用户没按下按键，但是超时时间到了，内核也会唤醒APP。</p>
<p>  所以APP被唤醒有2种原因：用户操作了按键，超时。被唤醒的APP在内核态继续运行，即继续执行驱动代码，把“状态”返回给APP(的用户空间)。</p>
<p>  APP得到poll/select函数的返回结果后，如果确认是有数据的，则再调用read函数，这会导致驱动中的read函数被调用，这时驱动程序中含有数据，会直接返回数据。</p>
</div>
<div class="section" id="id142">
<h4>异步通知方式<a class="headerlink" href="#id142" title="永久链接至标题">¶</a></h4>
<div class="section" id="id143">
<h5>异步通知的原理：发信号=====<a class="headerlink" href="#id143" title="永久链接至标题">¶</a></h5>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_114.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_114.png" />
&lt;800px&gt;
  异步通知的实现原理是：内核给APP发信号。信号有很多种，这里发的是SIGIO。</p>
<p>  驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read,fasync函数。</p>
<p>  APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。</p>
<p>  APP给信号SIGIO注册自己的处理函数：my_signal_fun。</p>
<p>  APP调用fcntl函数，把驱动程序的flag改为FASYNC，这会导致驱动程序的fasync函数被调用，它只是简单记录进程PID。</p>
<p>  当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，然后给进程PID发送SIGIO信号。</p>
<p>  APP收到信号后会被打断，先执行信号处理函数：在信号处理函数中可以去调用read函数读取按键值。</p>
<p>  信号处理函数返回后，APP会继续执行原先被打断的代码。</p>
</div>
<div class="section" id="id144">
<h5>应用程序之间发信号示例代码<a class="headerlink" href="#id144" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\0</span>3_signal_example   
</pre></div>
</div>
<p>  代码并不复杂，如下。</p>
<p>  第13行注册信号处理函数，第15行就是一个无限循环。在它运行期间，你可以用另一个APP发信号给它。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>	01 # include &lt;stdio.h&gt;   
	02 # include &lt;unistd.h&gt;   
	03 # include &lt;signal.h&gt;   
	04 void my_sig_func(int signo)   
	05 {   
	06    printf(&quot;get a signal : %d\n&quot;, signo);   
	07 }   
	08   
	09 int main(int argc, char **argv)   
	10 {   
	11    int i = 0;   
	12   
	13    signal(SIGIO, my_sig_func);   
	14   
	15    while (1)   
	16    {   
	17       printf(&quot;Hello, world %d!\n&quot;, i++);   
	18       sleep(2);   
	19    }   
	20   
	21    return 0;   
	22 }   
</pre></div>
</div>
<p>  在Ubuntu上的测试方法：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		$ gcc   -o   signal  signal.c   // 编译程序   
		$ ./signal <span class="p">&amp;</span>               // 后台运行   
		$ ps  -A <span class="p">|</span> grep signal        // 查看进程ID，假设是9527   
		$ <span class="nb">kill</span>  -SIGIO  <span class="m">9527</span>         // 给这个进程发信号   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id145">
<h4>驱动程序提供能力，不提供策略<a class="headerlink" href="#id145" title="永久链接至标题">¶</a></h4>
<p>  我们的驱动程序可以实现上述4种提供按键的方法，但是驱动程序不应该限制APP使用哪种方法。</p>
<p>  这就是驱动设计的一个原理：提供能力，不提供策略。就是说，你想用哪种方法都行，驱动程序都可以提供；但是驱动程序不能限制你使用哪种方法。</p>
</div>
</div>
</div>
<div class="section" id="id146">
<h2>查询方式的按键驱动程序_编写框架<a class="headerlink" href="#id146" title="永久链接至标题">¶</a></h2>
<div class="section" id="id147">
<h3>LED驱动回顾<a class="headerlink" href="#id147" title="永久链接至标题">¶</a></h3>
<p>  对于LED，APP调用open函数导致驱动程序的led_open函数被调用。在里面，把GPIO配置为输出引脚。安装驱动程序后并不意味着会使用对应的硬件，而APP要使用对应的硬件，必须先调用open函数。所以建议在驱动程序的open函数中去设置引脚。</p>
<p>  APP继续调用write函数传入数值，在驱动程序的led_write函数根据该数值去设置GPIO的数据寄存器，从而控制GPIO的输出电平。</p>
<p>  怎么操作寄存器？从芯片手册得到对应寄存器的物理地址，在驱动程序中使用ioremap函数映射得到虚拟地址。驱动程序中使用虚拟地址去访问寄存器。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_045.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_045.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id148">
<h3>按键驱动编写思路<a class="headerlink" href="#id148" title="永久链接至标题">¶</a></h3>
<p>  GPIO按键的原理图一般有如下2种：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_115.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_115.png" />
&lt;400px&gt;</p>
<p>  按键没被按下时，上图中左边的GPIO电平为高，右边的GPIO电平为低。</p>
<p>  按键被按下后，上图中左边的GPIO电平为低，右边的GPIO电平为高。</p>
<p>  编写按键驱动程序最简单的方法如下图所示：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_116.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_116.png" />
&lt;600px&gt;</p>
<p>  回顾一下编写驱动程序的套路：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_040.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_040.png" />
&lt;600px&gt;</p>
<p>  对于使用查询方式的按键驱动程序，我们只需要实现button_open、button_read。</p>
</div>
<div class="section" id="id149">
<h3>编程：先写框架<a class="headerlink" href="#id149" title="永久链接至标题">¶</a></h3>
<p>  我们的目的写出一个容易扩展到各种芯片、各种板子的按键驱动程序，所以驱动程序分为上下两层：</p>
<p>    ① button_drv.c分配/设置/注册file_operations结构体</p>
<p>      起承上启下的作用，向上提供button_open,button_read供APP调用。</p>
<p>      而这2个函数又会调用底层硬件提供的p_button_opr中的init、read函数操作硬件。</p>
<p>    ② board_xxx.c分配/设置/注册button_operations结构体</p>
<p>      这个结构体是我们自己抽象出来的，里面定义单板xxx的按键操作函数。</p>
<p>  这样的结构易于扩展，对于不同的单板，只需要替换board_xxx.c提供自己的button_operations结构体即可。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_117.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_117.png" />
&lt;800px&gt;</p>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\ </span>  
			04_button_drv<span class="se">\0</span>1_button_drv_template   
</pre></div>
</div>
<div class="section" id="button-operations">
<h4>把按键的操作抽象出一个button_operations结构体<a class="headerlink" href="#button-operations" title="永久链接至标题">¶</a></h4>
<p>  首先看看button_drv.h，它定义了一个button_operations结构体，把按键的操作抽象为这个结构体：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mo">04</span> <span class="k">struct</span> <span class="n">button_operations</span> <span class="p">{</span>   
		<span class="mo">05</span>    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>   
		<span class="mo">06</span>    <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">);</span>   
		<span class="mo">07</span>    <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">);</span>   
		<span class="mi">08</span> <span class="p">};</span>   
		<span class="mi">09</span>   
		<span class="mi">10</span> <span class="kt">void</span> <span class="nf">register_button_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">button_operations</span> <span class="o">*</span><span class="n">opr</span><span class="p">);</span>   
		<span class="mi">11</span> <span class="kt">void</span> <span class="nf">unregister_button_operations</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>   
		<span class="mi">12</span>   
</pre></div>
</div>
<p>  再看看board_xxx.c，它实现了一个button_operations结构体，代码如下。</p>
<p>  第 45 行调用register_button_operations函数，把这个结构体注册到上层驱动中。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">37</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">button_operations</span> <span class="n">my_buttons_ops</span> <span class="o">=</span><span class="p">{</span>   
		<span class="mi">38</span>    <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>   
		<span class="mi">39</span>    <span class="p">.</span><span class="n">init</span>  <span class="o">=</span> <span class="n">board_xxx_button_init_gpio</span><span class="p">,</span>   
		<span class="mi">40</span>    <span class="p">.</span><span class="n">read</span>  <span class="o">=</span> <span class="n">board_xxx_button_read_gpio</span><span class="p">,</span>   
		<span class="mi">41</span> <span class="p">};</span>   
		<span class="mi">42</span>   
		<span class="mi">43</span> <span class="kt">int</span> <span class="nf">board_xxx_button_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
		<span class="mi">44</span> <span class="p">{</span>   
		<span class="mi">45</span>    <span class="n">register_button_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_buttons_ops</span><span class="p">);</span>   
		<span class="mi">46</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">47</span> <span class="p">}</span>   
		<span class="mi">48</span>   
</pre></div>
</div>
</div>
<div class="section" id="id150">
<h4>驱动程序的上层：file_operations结构体<a class="headerlink" href="#id150" title="永久链接至标题">¶</a></h4>
<p>  上层是button_drv.c，它的核心是file_operations结构体，首先看看入口函数，代码如下。</p>
<p>  第 83 行向内核注册一个file_operations结构体。</p>
<p>  第 85 行创建一个class，但是该class下还没有device，在后面获得底层硬件的信息时再在class下创建device：这只是用来创建设备节点，它不是驱动程序的核心。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">81</span> <span class="kt">int</span> <span class="nf">button_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
		<span class="mi">82</span> <span class="p">{</span>   
		<span class="mi">83</span>    <span class="n">major</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;100ask_button&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">button_fops</span><span class="p">);</span>   
		<span class="mi">84</span>   
		<span class="mi">85</span>    <span class="n">button_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&quot;100ask_button&quot;</span><span class="p">);</span>   
		<span class="mi">86</span>    <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">button_class</span><span class="p">))</span>   
		<span class="mi">87</span>       <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   
		<span class="mi">88</span>   
		<span class="mi">89</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">90</span> <span class="p">}</span>   
		<span class="mi">91</span>   
</pre></div>
</div>
<p>  再来看看button_drv.c中file_operations结构体的成员函数，代码如下。</p>
<p>  第 34 、 44 行都用到一个button_operations指针，它是从何而来？</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">28</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">button_operations</span> <span class="o">*</span><span class="n">p_button_opr</span><span class="p">;</span>   
		<span class="mi">29</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">button_class</span><span class="p">;</span>   
		<span class="mi">30</span>   
		<span class="mi">31</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">button_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>   
		<span class="mi">32</span> <span class="p">{</span>   
		<span class="mi">33</span>    <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>   
		<span class="mi">34</span>    <span class="n">p_button_opr</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">minor</span><span class="p">);</span>   
		<span class="mi">35</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">36</span> <span class="p">}</span>   
		<span class="mi">37</span>   
		<span class="mi">38</span> <span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">button_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>   
		<span class="mi">39</span> <span class="p">{</span>   
		<span class="mi">40</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>   
		<span class="mi">41</span>    <span class="kt">char</span> <span class="n">level</span><span class="p">;</span>   
		<span class="mi">42</span>    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>   
		<span class="mi">43</span>   
		<span class="mi">44</span>    <span class="n">level</span> <span class="o">=</span> <span class="n">p_button_opr</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">minor</span><span class="p">);</span>   
		<span class="mi">45</span>    <span class="n">err</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">level</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   
		<span class="mi">46</span>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>   
		<span class="mi">47</span> <span class="p">}</span>   
		<span class="mi">48</span>   
		<span class="mi">49</span>   
		<span class="mi">50</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">button_fops</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">51</span>    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">button_open</span><span class="p">,</span>   
		<span class="mi">52</span>    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">button_read</span><span class="p">,</span>   
		<span class="mi">53</span> <span class="p">};</span>   
</pre></div>
</div>
<p>  上面第34、44行都用到一个button_operations指针，来自于底层硬件相关的代码。</p>
<p>  底层代码调用register_button_operations函数，向上提供这个结构体指针。</p>
<p>  register_button_operations函数代码如下，它还根据底层提供的button_operations调用device_create，这是创建设备节点(第62行)。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">55</span> <span class="kt">void</span> <span class="nf">register_button_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">button_operations</span> <span class="o">*</span><span class="n">opr</span><span class="p">)</span>   
		<span class="mi">56</span> <span class="p">{</span>   
		<span class="mi">57</span>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   
		<span class="mi">58</span>   
		<span class="mi">59</span>    <span class="n">p_button_opr</span> <span class="o">=</span> <span class="n">opr</span><span class="p">;</span>   
		<span class="mi">60</span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">opr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>   
		<span class="mi">61</span>    <span class="p">{</span>   
		<span class="mi">62</span>       <span class="n">device_create</span><span class="p">(</span><span class="n">button_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;100ask_button%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>   
		<span class="mi">63</span>    <span class="p">}</span>   
		<span class="mi">64</span> <span class="p">}</span>   
		<span class="mi">65</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id151">
<h3>测试<a class="headerlink" href="#id151" title="永久链接至标题">¶</a></h3>
<p>  这只是一个示例程序，还没有真正操作硬件。测试程序操作驱动程序时，只会导致驱动程序中打印信息。</p>
<p>  首先设置交叉工具链，修改驱动Makefile中内核的源码路径，编译驱动和测试程序。</p>
<p>  启动开发板后，通过NFS访问编译好驱动程序、测试程序，就可以在开发板上如下操作了：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1">#  insmod button_drv.ko   // 装载驱动程序   </span>
		<span class="o">[</span>  <span class="m">435</span>.276713<span class="o">]</span> button_drv: loading out-of-tree module taints kernel.   
		<span class="c1">#  insmod board_xxx.ko   </span>
		<span class="c1">#  ls /dev/100ask_button* -l    // 查看设备节点   </span>
		crw-------   <span class="m">1</span> root    root     <span class="m">236</span>,   <span class="m">0</span> Jan <span class="m">18</span> <span class="m">08</span>:57 /dev/100ask_button0   
		crw-------   <span class="m">1</span> root    root     <span class="m">236</span>,   <span class="m">1</span> Jan <span class="m">18</span> <span class="m">08</span>:57 /dev/100ask_button1   
		<span class="c1">#  ./button_test /dev/100ask_button0   // 读按键   </span>
		<span class="o">[</span>  <span class="m">450</span>.886180<span class="o">]</span> /home/book/source/04_button_drv/01_button_drv_template/board_xxx.c board_xxx_button_init_gpio <span class="m">28</span>, init gpio <span class="k">for</span> button <span class="m">0</span>   
		<span class="o">[</span>  <span class="m">450</span>.910915<span class="o">]</span> /home/book/source/04_button_drv/01_button_drv_template/board_xxx.c board_xxx_button_read_gpio <span class="m">33</span>, <span class="nb">read</span> gpio <span class="k">for</span> button <span class="m">0</span>   
		get button : <span class="m">1</span>   // 得到数据   
</pre></div>
</div>
</div>
<div class="section" id="id152">
<h3>课后怎业<a class="headerlink" href="#id152" title="永久链接至标题">¶</a></h3>
<p>  合并LED、BUTTON框架驱动程序：01_led_drv_template、01_button_drv_template，合并为：gpio_drv_template</p>
</div>
</div>
<div class="section" id="id153">
<h2>具体单板的按键驱动程序(查询方式)<a class="headerlink" href="#id153" title="永久链接至标题">¶</a></h2>
<div class="section" id="id154">
<h3>GPIO操作回顾<a class="headerlink" href="#id154" title="永久链接至标题">¶</a></h3>
<p>  参考第4章《普适的GPIO引脚操作方法》、第5章《具体单板的GPIO操作方法》。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_118.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_118.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="am335x">
<h3>AM335X的按键驱动程序(查询方式)<a class="headerlink" href="#am335x" title="永久链接至标题">¶</a></h3>
<div class="section" id="id155">
<h4>先看原理图确定引脚及操作方法<a class="headerlink" href="#id155" title="永久链接至标题">¶</a></h4>
<p>  AM335X是底板+核心板的结构，打开底板原理图100ask_am335x_v12_原理图.pdf，它有4个按键，本视频只操作一个按键，原理图如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_119.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_119.png" />
&lt;400px&gt;</p>
<p>  平时按键电平为高，按下按键后电平为低。</p>
<p>  按键引脚为GPIO1_25。</p>
</div>
<div class="section" id="id156">
<h4>再看芯片手册确定寄存器及操作方法<a class="headerlink" href="#id156" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_120.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_120.png" />
&lt;600px&gt;</p>
<p>  步骤1：使能GPIO1模块</p>
<p>    设置CM_PER_GPIO1_CLKCTRL寄存器的bit[18]为1，bit[1:0]为0x2，该寄存器地址为0x44E00000+0xAC。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_121.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_121.png" />
&lt;600px&gt;</p>
<p>  步骤2：把GPIO1_25对应的引脚设置为GPIO模式</p>
<p>    要用哪一个寄存器来把GPIO1_25对应的引脚设置为GPIO模式？</p>
<p>      ① 在核心板原理图ET-som335X原理图.pdf里搜“GPIO1_25”，可以看到下图，确定pin number为U16：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_122.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_122.png" />
&lt;600px&gt;</p>
<p>      ② 在芯片手册AM335x Sitara™ Processors.pdf里搜“U16”，可得下图，引脚名为GPMC_A9，用作GPIO时要设置为mode 7：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_123.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_123.png" />
&lt;600px&gt;</p>
<p>      ③ 在芯片手册AM335x_datasheet_spruh73p.pdf中搜gpmc_a9，</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_124.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_124.png" />
&lt;600px&gt;</p>
<p>      所以，要把GPIO1_25对应的引脚设置为GPIO模式，要设置conf_gpmc_a9寄存器的bit[5]为1，bit[2:0]为7，这个寄存器的地址是 0x44E10000+0x864。</p>
<p>  步骤3：设置GPIO1内部寄存器，把GPIO1_25设置为输入引脚，读数据寄存器</p>
<p>    GPIO_OE寄存器：地址为0x4804C000+0x134，bit[25]设置为1。</p>
<p>    GPIO_DATAIN寄存器：地址为0x4804C000+0x138，读其bit[25]。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_125.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_125.png" />
&lt;600px&gt;</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_126.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_126.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id157">
<h4>编程<a class="headerlink" href="#id157" title="永久链接至标题">¶</a></h4>
<div class="section" id="id158">
<h5>程序框架<a class="headerlink" href="#id158" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
			02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\ </span>  
				04_button_drv<span class="se">\0</span>2_button_drv_for_boards<span class="se">\0</span>1_button_drv_for_am335x   
</pre></div>
</div>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_127.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_127.png" />
&lt;800px&gt;</p>
</div>
<div class="section" id="id159">
<h5>硬件相关的代码<a class="headerlink" href="#id159" title="永久链接至标题">¶</a></h5>
<p>  主要看board_am335x.c，先看它的入口函数，代码如下。</p>
<p>  第84行向上层驱动注册一个button_operations结构体，该结构体在第76～80行定义。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">76</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">button_operations</span> <span class="n">my_buttons_ops</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">77</span>    <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
		<span class="mi">78</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_am335x_button_init</span><span class="p">,</span>   
		<span class="mi">79</span>    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">board_am335x_button_read</span><span class="p">,</span>   
		<span class="mi">80</span> <span class="p">};</span>   
		<span class="mi">81</span>   
		<span class="mi">82</span> <span class="kt">int</span> <span class="nf">board_am335x_button_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
		<span class="mi">83</span> <span class="p">{</span>   
		<span class="mi">84</span>    <span class="n">register_button_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_buttons_ops</span><span class="p">);</span>   
		<span class="mi">85</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">86</span> <span class="p">}</span>   
		<span class="mi">87</span>   
</pre></div>
</div>
<p>  button_operations结构体中有init函数指针，它指向board_am335x_button_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。代码如下。</p>
<p>  值得关注的是第32～35行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">21</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">CM_PER_GPIO1_CLKCTRL</span><span class="p">;</span>   
		<span class="mi">22</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">conf_gpmc_a9</span><span class="p">;</span>   
		<span class="mi">23</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO1_OE</span><span class="p">;</span>   
		<span class="mi">24</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO1_DATAIN</span><span class="p">;</span>   
		<span class="mi">25</span>   
		<span class="mi">26</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">board_am335x_button_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化button, which-哪个button */</span>   
		<span class="mi">27</span> <span class="p">{</span>   
		<span class="mi">28</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">29</span>    <span class="p">{</span>   
		<span class="mi">30</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CM_PER_GPIO1_CLKCTRL</span><span class="p">)</span>   
		<span class="mi">31</span>       <span class="p">{</span>   
		<span class="mi">32</span>          <span class="n">CM_PER_GPIO1_CLKCTRL</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x44E00000</span> <span class="o">+</span> <span class="mh">0xAC</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">33</span>          <span class="n">conf_gpmc_a9</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x44E10000</span> <span class="o">+</span> <span class="mh">0x864</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">34</span>          <span class="n">GPIO1_OE</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x4804C000</span> <span class="o">+</span> <span class="mh">0x134</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">35</span>          <span class="n">GPIO1_DATAIN</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x4804C000</span> <span class="o">+</span> <span class="mh">0x138</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">36</span>       <span class="p">}</span>   
		<span class="mi">37</span>   
		<span class="mi">38</span>       <span class="c1">//printk(&quot;%s %s line %d, led %d\n&quot;, __FILE__, __FUNCTION__, __LINE__, which);   </span>
		<span class="mi">39</span>       <span class="cm">/* a. 使能GPIO1   </span>
<span class="cm">		40        * set PRCM to enalbe GPIO1   </span>
<span class="cm">		41        * set CM_PER_GPIO1_CLKCTRL (0x44E00000 + 0xAC)   </span>
<span class="cm">		42        * val: (1&lt;&lt;18) | 0x2   </span>
<span class="cm">		43        */</span>   
		<span class="mi">44</span>       <span class="o">*</span><span class="n">CM_PER_GPIO1_CLKCTRL</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x2</span><span class="p">;</span>   
		<span class="mi">45</span>   
		<span class="mi">46</span>       <span class="cm">/* b. 设置GPIO1_25的功能，让它工作于GPIO模式   </span>
<span class="cm">		47        * set Control Module to set GPIO1_25 (U16) used as GPIO   </span>
<span class="cm">		48        * conf_gpmc_a9 as mode 7   </span>
<span class="cm">		49        * addr : 0x44E10000 + 0x864   </span>
<span class="cm">		50        * bit[5]   : 1, Input enable value for the PAD   </span>
<span class="cm">		51        * bit[2:0] : mode 7   </span>
<span class="cm">		52        */</span>   
		<span class="mi">53</span>       <span class="o">*</span><span class="n">conf_gpmc_a9</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="mi">7</span><span class="p">;</span>   
		<span class="mi">54</span>   
		<span class="mi">55</span>       <span class="cm">/* c. 设置GPIO1_25的方向，让它作为输入引脚   </span>
<span class="cm">		56        * set GPIO1&#39;s registers , to set 设置GPIO1_25的方向&#39;S dir (input)   </span>
<span class="cm">		57        * GPIO_OE   </span>
<span class="cm">		58        * addr : 0x4804C000 + 0x134   </span>
<span class="cm">		59        * set bit 25   </span>
<span class="cm">		60        */</span>   
		<span class="mi">61</span>   
		<span class="mi">62</span>       <span class="o">*</span><span class="n">GPIO1_OE</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">25</span><span class="p">);</span>   
		<span class="mi">63</span>    <span class="p">}</span>   
		<span class="mi">64</span>   
		<span class="mi">65</span> <span class="p">}</span>   
		<span class="mi">66</span>   
</pre></div>
</div>
<p>  button_operations结构体中还有有read函数指针，它指向board_am335x_button_read函数，在里面将会读取并返回按键引脚的电平。代码如下。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">67</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_am335x_button_read</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 读button, which-哪个 */</span>   
		<span class="mi">68</span> <span class="p">{</span>   
		<span class="mi">69</span>    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %s line %d, button %d, 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">*</span><span class="n">GPIO1_DATAIN</span><span class="p">);</span>   
		<span class="mi">70</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">71</span>       <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">GPIO1_DATAIN</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">25</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">72</span>    <span class="k">else</span>   
		<span class="mi">73</span>       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">74</span> <span class="p">}</span>   
		<span class="mi">75</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id160">
<h4>测试<a class="headerlink" href="#id160" title="永久链接至标题">¶</a></h4>
<p>  安装驱动程序之后执行测试程序，观察它的返回值(执行测试程序的同时操作按键)：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1">#  insmod button_drv.ko   </span>
		<span class="c1">#  insmod board_am335x.ko   </span>
		<span class="c1">#  ./button_test /dev/100ask_button0   </span>
</pre></div>
</div>
</div>
<div class="section" id="id161">
<h4>课后作业<a class="headerlink" href="#id161" title="永久链接至标题">¶</a></h4>
<p>  ① 修改board_am335x.c，增加更多按键</p>
<p>  ② 修改button_test.c，使用按键来点灯</p>
</div>
</div>
<div class="section" id="id162">
<h3>RK3288的按键驱动程序(查询方式)<a class="headerlink" href="#id162" title="永久链接至标题">¶</a></h3>
<div class="section" id="id163">
<h4>先看原理图确定引脚及操作方法<a class="headerlink" href="#id163" title="永久链接至标题">¶</a></h4>
<p>  Firefly的RK3288开发板上没有按键，我们为它制作的扩展板上有1个按键。在扩展板原理图rk3288_extend_v12_0715.pdf中可以看到按键，如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_128.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_128.png" />
&lt;400px&gt;</p>
<p>  平时按键电平为高，按下按键后电平为低。</p>
<p>  按键引脚为GPIO7_B1。</p>
</div>
<div class="section" id="id164">
<h4>再看芯片手册确定寄存器及操作方法<a class="headerlink" href="#id164" title="永久链接至标题">¶</a></h4>
<p>  芯片手册为Rockchip_RK3288_TRM_V1.2_Part1-20170321.pdf，不过我们总结如下。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_129.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_129.png" />
&lt;600px&gt;</p>
<p>  步骤1：使能GPIO7模块</p>
<p>    设置CRU_CLKGATE14_CON寄存器的bit[7]为0。</p>
<p>    要设置bit7，必须同时设置bit23为1。</p>
<p>    该寄存器地址为0xFF760000+0x198。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_130.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_130.png" />
&lt;600px&gt;</p>
<p>  步骤2：把GPIO7_B1对应的引脚设置为GPIO模式</p>
<p>    设置GRF_GPIO7B_IOMUX寄存器的bit[3:2]为0b00。</p>
<p>    要设置bit[3:2]，必须同时设置bit[19:18]为0b11。</p>
<p>    该寄存器地址为0xFF770000+0x0070。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_131.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_131.png" />
&lt;600px&gt;</p>
<p>  步骤3：设置GPIO7内部寄存器，把GPIO7_B1设置为输入引脚，读数据寄存器</p>
<p>    GPIO_SWPORTA_DDR方向寄存器：地址为0xFF7E0000+ 0x0004，bit[9]设置为0。</p>
<p>    GPIO_EXT_PORTA外部端口寄存器：地址为0xFF7E0000+ 0x0050，读其bit[9]。</p>
<p>    <font color="# dd0000">注意：</font></p>
<p>      GPIO_A0~A7 对应bit0~bit7；GPIO_B0~B7 对应bit8~bit15；</p>
<p>      GPIO_C0~C7 对应bit16~bit23；GPIO_D0~D7 对应bit24~bit31</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_132.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_132.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id165">
<h4>编程<a class="headerlink" href="#id165" title="永久链接至标题">¶</a></h4>
<div class="section" id="id166">
<h5>程序框架<a class="headerlink" href="#id166" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
			02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\ </span>  
				04_button_drv<span class="se">\0</span>2_button_drv_for_boards<span class="se">\0</span>2_button_drv_for_rk3288   
</pre></div>
</div>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_133.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_133.png" />
&lt;800px&gt;</p>
</div>
<div class="section" id="id167">
<h5>硬件相关的代码<a class="headerlink" href="#id167" title="永久链接至标题">¶</a></h5>
<p>  主要看board_rk3288.c，先看它的入口函数，代码如下。</p>
<p>  第 81 行向上层驱动注册一个button_operations结构体，该结构体在第73～77行定义。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">73</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">button_operations</span> <span class="n">my_buttons_ops</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">74</span>    <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
		<span class="mi">75</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_rk3288_button_init</span><span class="p">,</span>   
		<span class="mi">76</span>    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">board_rk3288_button_read</span><span class="p">,</span>   
		<span class="mi">77</span> <span class="p">};</span>   
		<span class="mi">78</span>   
		<span class="mi">79</span> <span class="kt">int</span> <span class="nf">board_rk3288_button_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
		<span class="mi">80</span> <span class="p">{</span>   
		<span class="mi">81</span>    <span class="n">register_button_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_buttons_ops</span><span class="p">);</span>   
		<span class="mi">82</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">83</span> <span class="p">}</span>   
</pre></div>
</div>
<p>  button_operations结构体中有init函数指针，它指向board_rk3288_button_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。代码如下。</p>
<p>  值得关注的是第32～35行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">21</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">CRU_CLKGATE14_CON</span><span class="p">;</span>   
		<span class="mi">22</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GRF_GPIO7B_IOMUX</span> <span class="p">;</span>   
		<span class="mi">23</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO7_SWPORTA_DDR</span><span class="p">;</span>   
		<span class="mi">24</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO7_EXT_PORTA</span> <span class="p">;</span>   
		<span class="mi">25</span>   
		<span class="mi">26</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">board_rk3288_button_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化button, which-哪个button */</span>   
		<span class="mi">27</span> <span class="p">{</span>   
		<span class="mi">28</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">29</span>    <span class="p">{</span>   
		<span class="mi">30</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CRU_CLKGATE14_CON</span><span class="p">)</span>   
		<span class="mi">31</span>       <span class="p">{</span>   
		<span class="mi">32</span>          <span class="n">CRU_CLKGATE14_CON</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF760000</span> <span class="o">+</span> <span class="mh">0x0198</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">33</span>          <span class="n">GRF_GPIO7B_IOMUX</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF770000</span> <span class="o">+</span> <span class="mh">0x0070</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">34</span>          <span class="n">GPIO7_SWPORTA_DDR</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF7E0000</span> <span class="o">+</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">35</span>          <span class="n">GPIO7_EXT_PORTA</span>   <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF7E0000</span> <span class="o">+</span> <span class="mh">0x0050</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">36</span>       <span class="p">}</span>   
		<span class="mi">37</span>   
		<span class="mi">38</span>       <span class="cm">/* rk3288 GPIO7_B1 */</span>   
		<span class="mi">39</span>       <span class="cm">/* a. 使能GPIO7   </span>
<span class="cm">		40        * set CRU to enable GPIO7   </span>
<span class="cm">		41        * CRU_CLKGATE14_CON 0xFF760000 + 0x198   </span>
<span class="cm">		42        * (1&lt;&lt;(7+16)) | (0&lt;&lt;7)   </span>
<span class="cm">		43        */</span>   
		<span class="mi">44</span>       <span class="o">*</span><span class="n">CRU_CLKGATE14_CON</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">);</span>   
		<span class="mi">45</span>   
		<span class="mi">46</span>       <span class="cm">/* b. 设置GPIO7_B1用于GPIO   </span>
<span class="cm">		47        * set PMU/GRF to configure GPIO7_B1 as GPIO   </span>
<span class="cm">		48        * GRF_GPIO7B_IOMUX 0xFF770000 + 0x0070   </span>
<span class="cm">		49        * bit[3:2] = 0b00   </span>
<span class="cm">		50        * (3&lt;&lt;(2+16)) | (0&lt;&lt;2)   </span>
<span class="cm">		51        */</span>   
		<span class="mi">52</span>       <span class="o">*</span><span class="n">GRF_GPIO7B_IOMUX</span> <span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>   
		<span class="mi">53</span>   
		<span class="mi">54</span>       <span class="cm">/* c. 设置GPIO7_B1作为input引脚   </span>
<span class="cm">		55        * set GPIO_SWPORTA_DDR to configure GPIO7_B1 as input   </span>
<span class="cm">		56        * GPIO_SWPORTA_DDR 0xFF7E0000 + 0x0004   </span>
<span class="cm">		57        * bit[9] = 0b0   </span>
<span class="cm">		58        */</span>   
		<span class="mi">59</span>       <span class="o">*</span><span class="n">GPIO7_SWPORTA_DDR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">);</span>   
		<span class="mi">60</span>    <span class="p">}</span>   
		<span class="mi">61</span>   
		<span class="mi">62</span> <span class="p">}</span>   
</pre></div>
</div>
<p>  button_operations结构体中还有有read函数指针，它指向board_rk3288_button_read函数，在里面将会读取并返回按键引脚的电平。代码如下。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">64</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_rk3288_button_read</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 读button, which-哪个 */</span>   
		<span class="mi">65</span> <span class="p">{</span>   
		<span class="mi">66</span>    <span class="c1">//printk(&quot;%s %s line %d, button %d, 0x%x\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, *GPIO1_DATAIN);   </span>
		<span class="mi">67</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">68</span>       <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">GPIO7_EXT_PORTA</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">69</span>    <span class="k">else</span>   
		<span class="mi">70</span>       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">71</span> <span class="p">}</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id168">
<h4>测试<a class="headerlink" href="#id168" title="永久链接至标题">¶</a></h4>
<p>  安装驱动程序之后执行测试程序，观察它的返回值(执行测试程序的同时操作按键)：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1">#  insmod button_drv.ko   </span>
		<span class="c1">#  insmod board_rk3288.ko   </span>
		<span class="c1">#  ./button_test /dev/100ask_button0   </span>
</pre></div>
</div>
</div>
<div class="section" id="id169">
<h4>课后作业<a class="headerlink" href="#id169" title="永久链接至标题">¶</a></h4>
<p>  ① 修改button_test.c，使用按键来点灯</p>
</div>
</div>
<div class="section" id="id170">
<h3>RK3399的按键驱动程序(查询方式)<a class="headerlink" href="#id170" title="永久链接至标题">¶</a></h3>
<div class="section" id="id171">
<h4>先看原理图确定引脚及操作方法<a class="headerlink" href="#id171" title="永久链接至标题">¶</a></h4>
<p>  Firefly的RK3399开发板上没有按键，我们为它制作的扩展板上有3个按键。在扩展板原理图rk3399_extend_v12_0709final.pdf中可以看到按键，如下：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_134.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_134.png" />
&lt;800px&gt;</p>
<p>  平时按键电平为高，按下按键后电平为低。</p>
<p>  按键引脚为GPIO0_B1、GPIO0_B2、GPIO0_B4。</p>
<p>  本视频中，只操作一个按键：GPIO0_B1。</p>
</div>
<div class="section" id="id172">
<h4>再看芯片手册确定寄存器及操作方法<a class="headerlink" href="#id172" title="永久链接至标题">¶</a></h4>
<p>  芯片手册为Rockchip RK3399TRM V1.3 Part1.pdf和Rockchip RK3399TRM V1.3 Part2.pdf，不过我们总结如下。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_135.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_135.png" />
&lt;600px&gt;</p>
<p>  步骤1：使能GPIO0模块</p>
<p>    设置PMUCRU_CLKGATE_CON1寄存器的bit[3]为0。</p>
<p>    要设置bit3，必须同时设置bit19为1。</p>
<p>    该寄存器地址为0xFF760000+ 0x0104。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_136.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_136.png" />
&lt;600px&gt;</p>
<p>  步骤2：把GPIO0_B1对应的引脚设置为GPIO模式</p>
<p>    设置PMUGRF_GPIO0B_IOMUX寄存器的bit[3:2]为0b00。</p>
<p>    要设置bit[3:2]，必须同时设置bit[19:18]为0b11。</p>
<p>    该寄存器地址为0xFF310000+0x0004。</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_137.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_137.png" />
&lt;600px&gt;</p>
<p>  步骤3：设置GPIO0内部寄存器，把GPIO0_B1设置为输入引脚，读数据寄存器</p>
<p>    这些寄存器的介绍在芯片手册Rockchip RK3399TRM V1.3 Part2.pdf中。</p>
<p>    GPIO_SWPORTA_DDR方向寄存器：地址为0xFF720000+ 0x0004，bit[9]设置为0。</p>
<p>    GPIO_EXT_PORTA外部端口寄存器：地址为0xFF720000+ 0x0050，读其bit[9]。</p>
<p>    <font color="# dd0000">注意：</font></p>
<p>      GPIO_A0~A7 对应bit0~bit7；GPIO_B0~B7 对应bit8~bit15；</p>
<p>      GPIO_C0~C7 对应bit16~bit23；GPIO_D0~D7 对应bit24~bit31</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_138.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_138.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id173">
<h4>编程<a class="headerlink" href="#id173" title="永久链接至标题">¶</a></h4>
<div class="section" id="id174">
<h5>程序框架<a class="headerlink" href="#id174" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
			02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\ </span>  
				04_button_drv<span class="se">\0</span>2_button_drv_for_boards<span class="se">\0</span>3_button_drv_for_rk3399   
</pre></div>
</div>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_139.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_139.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id175">
<h5>硬件相关的代码<a class="headerlink" href="#id175" title="永久链接至标题">¶</a></h5>
<p>  主要看board_rk3399.c，先看它的入口函数，代码如下。</p>
<p>  第81行向上层驱动注册一个button_operations结构体，该结构体在第73～77行定义。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">73</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">button_operations</span> <span class="n">my_buttons_ops</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">74</span>    <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   
		<span class="mi">75</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_rk3399_button_init</span><span class="p">,</span>   
		<span class="mi">76</span>    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">board_rk3399_button_read</span><span class="p">,</span>   
		<span class="mi">77</span> <span class="p">};</span>   
		<span class="mi">78</span>   
		<span class="mi">79</span> <span class="kt">int</span> <span class="nf">board_rk3399_button_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
		<span class="mi">80</span> <span class="p">{</span>   
		<span class="mi">81</span>    <span class="n">register_button_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_buttons_ops</span><span class="p">);</span>   
		<span class="mi">82</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">83</span> <span class="p">}</span>   
</pre></div>
</div>
<p>  button_operations结构体中有init函数指针，它指向board_rk3399_button_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。代码如下。</p>
<p>  值得关注的是第32～35行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">21</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">PMUCRU_CLKGATE_CON1</span><span class="p">;</span>   
		<span class="mi">22</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GRF_GPIO0B_IOMUX</span> <span class="p">;</span>   
		<span class="mi">23</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO0_SWPORTA_DDR</span><span class="p">;</span>   
		<span class="mi">24</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">GPIO0_EXT_PORTA</span> <span class="p">;</span>   
		<span class="mi">25</span>   
		<span class="mi">26</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">board_rk3399_button_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化button, which-哪个button */</span>   
		<span class="mi">27</span> <span class="p">{</span>   
		<span class="mi">28</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">29</span>    <span class="p">{</span>   
		<span class="mi">30</span>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PMUCRU_CLKGATE_CON1</span><span class="p">)</span>   
		<span class="mi">31</span>       <span class="p">{</span>   
		<span class="mi">32</span>          <span class="n">PMUCRU_CLKGATE_CON1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF760000</span><span class="o">+</span> <span class="mh">0x0104</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">33</span>          <span class="n">GRF_GPIO0B_IOMUX</span>  <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF310000</span><span class="o">+</span><span class="mh">0x0004</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">34</span>          <span class="n">GPIO0_SWPORTA_DDR</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF720000</span> <span class="o">+</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">35</span>          <span class="n">GPIO0_EXT_PORTA</span>   <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xFF720000</span> <span class="o">+</span> <span class="mh">0x0050</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">36</span>       <span class="p">}</span>   
		<span class="mi">37</span>   
		<span class="mi">38</span>       <span class="cm">/* rk3399 GPIO0_B1 */</span>   
		<span class="mi">39</span>       <span class="cm">/* a. 使能GPIO0   </span>
<span class="cm">		40        * set CRU to enable GPIO0   </span>
<span class="cm">		41        * PMUCRU_CLKGATE_CON1 0xFF760000+ 0x0104   </span>
<span class="cm">		42        * (1&lt;&lt;(3+16)) | (0&lt;&lt;3)   </span>
<span class="cm">		43        */</span>   
		<span class="mi">44</span>       <span class="o">*</span><span class="n">PMUCRU_CLKGATE_CON1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">);</span>   
		<span class="mi">45</span>   
		<span class="mi">46</span>       <span class="cm">/* b. 设置GPIO0_B1用于GPIO   </span>
<span class="cm">		47        * set PMU/GRF to configure GPIO0_B1 as GPIO   </span>
<span class="cm">		48        * GRF_GPIO0B_IOMUX 0xFF310000+0x0004   </span>
<span class="cm">		49        * bit[3:2] = 0b00   </span>
<span class="cm">		50        * (3&lt;&lt;(2+16)) | (0&lt;&lt;2)   </span>
<span class="cm">		51        */</span>   
		<span class="mi">52</span>       <span class="o">*</span><span class="n">GRF_GPIO0B_IOMUX</span> <span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">16</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">);</span>   
		<span class="mi">53</span>   
		<span class="mi">54</span>       <span class="cm">/* c. 设置GPIO0_B1作为input引脚   </span>
<span class="cm">		55        * set GPIO_SWPORTA_DDR to configure GPIO0_B1 as input   </span>
<span class="cm">		56        * GPIO_SWPORTA_DDR 0xFF720000 + 0x0004   </span>
<span class="cm">		57        * bit[9] = 0b0   </span>
<span class="cm">		58        */</span>   
		<span class="mi">59</span>       <span class="o">*</span><span class="n">GPIO0_SWPORTA_DDR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">);</span>   
		<span class="mi">60</span>    <span class="p">}</span>   
		<span class="mi">61</span>   
		<span class="mi">62</span> <span class="p">}</span>   
</pre></div>
</div>
<p>  button_operations结构体中还有有read函数指针，它指向board_rk3399_button_read函数，在里面将会读取并返回按键引脚的电平。代码如下。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">64</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_rk3399_button_read</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 读button, which-哪个 */</span>   
		<span class="mi">65</span> <span class="p">{</span>   
		<span class="mi">66</span>   <span class="c1">//printk(&quot;%s %s line %d, button %d, 0x%x\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, *GPIO1_DATAIN);   </span>
		<span class="mi">67</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">68</span>       <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">GPIO0_EXT_PORTA</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">9</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">69</span>    <span class="k">else</span>   
		<span class="mi">70</span>       <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">71</span> <span class="p">}</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id176">
<h4>测试<a class="headerlink" href="#id176" title="永久链接至标题">¶</a></h4>
<p>  安装驱动程序之后执行测试程序，观察它的返回值(执行测试程序的同时操作按键)：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>		<span class="c1">#  insmod button_drv.ko   </span>
		<span class="c1">#  insmod board_rk3399.ko   </span>
		<span class="c1">#  ./button_test /dev/100ask_button0   </span>
</pre></div>
</div>
</div>
<div class="section" id="id177">
<h4>课后作业<a class="headerlink" href="#id177" title="永久链接至标题">¶</a></h4>
<p>  ① 修改board_rk3399.c，增加更多按键</p>
<p>  ② 修改button_test.c，使用按键来点灯</p>
</div>
</div>
<div class="section" id="imx6ull-qemu">
<h3>百问网IMX6ULL-QEMU的按键驱动程序(查询方式)<a class="headerlink" href="#imx6ull-qemu" title="永久链接至标题">¶</a></h3>
<p>  使用QEMU模拟的硬件，它的硬件资源可以随意扩展。</p>
<p>  在IMX6ULL QEMU 虚拟开发板上，我们为它设计了2个 按键。在QEMU的GUI上有4个按键，右边的2个留待以后用于电源管理。</p>
<div class="section" id="id178">
<h4>先看原理图确定引脚及操作方法<a class="headerlink" href="#id178" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_140.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_140.png" />
&lt;600px&gt;</p>
<p>  平时按键电平为低，按下按键后电平为高。</p>
<p>  按键引脚为GPIO5_IO01、GPIO1_IO18。</p>
</div>
<div class="section" id="id179">
<h4>再看芯片手册确定寄存器及操作方法<a class="headerlink" href="#id179" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_023.png" />
&lt;600px&gt;
  步骤1：使能GPIO1、GPIO5</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_078.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_078.png" />
&lt;600px&gt;</p>
<p>    设置b[31:30]、b[27:26]就可以使能GPIO5、GPIO1，设置为什么值呢？</p>
<p>    看下图，设置为0b11：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_141.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_141.png" />
&lt;600px&gt;</p>
<p>      ① 00：该GPIO模块全程被关闭</p>
<p>      ② 01：该GPIO模块在CPU run mode情况下是使能的；在WAIT或STOP模式下，关闭</p>
<p>      ③ 10：保留</p>
<p>      ④ 11：该GPIO模块全程使能</p>
<p>  步骤2：设置GPIO5_IO01、GPIO1_IO18为GPIO模式</p>
<p>    ① 对于GPIO5_IO01，设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_142.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_142.png" />
&lt;600px&gt;</p>
<p>    ② 对于GPIO1_IO18，设置如下寄存器：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_001.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_001.png" />
&lt;600px&gt;</p>
<p>  步骤3：设置GPIO5_IO01、GPIO1_IO18为输入引脚，读取引脚电平</p>
<p>    寄存器地址为：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_072.png" />
&lt;600px&gt;</p>
<p>    设置方向寄存器，把引脚设置为输出引脚：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_073.png" />
&lt;600px&gt;</p>
<p>    读取引脚状态寄存器，得到引脚电平：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_143.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_143.png" />
&lt;600px&gt;</p>
</div>
<div class="section" id="id180">
<h4>编程<a class="headerlink" href="#id180" title="永久链接至标题">¶</a></h4>
<div class="section" id="id181">
<h5>程序框架<a class="headerlink" href="#id181" title="永久链接至标题">¶</a></h5>
<p>  使用GIT下载所有源码后，本节源码位于如下目录：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	 01_all_series_quickstart<span class="se">\0</span>4_快速入门<span class="o">(</span>正式开始<span class="o">)</span><span class="se">\ </span>  
	 		02_嵌入式Linux驱动开发基础知识<span class="se">\s</span>ource<span class="se">\ </span>  
	 			04_button_drv<span class="se">\0</span>2_button_drv_for_boards<span class="se">\0</span>4_button_drv_for_100ask_imx6ull-qemu   
</pre></div>
</div>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_144.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_144.png" />
&lt;800px&gt;</p>
</div>
<div class="section" id="id182">
<h5>硬件相关的代码<a class="headerlink" href="#id182" title="永久链接至标题">¶</a></h5>
<p>  主要看board_100ask_imx6ull-qemu.c。</p>
<p>  涉及的寄存器挺多，一个一个去执行ioremap效率太低。</p>
<p>  先定义结构体，然后对结构体指针进行ioremap。</p>
<p>  对于IOMUXC，可以如下定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">struct</span> <span class="n">iomux</span> <span class="p">{</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unnames</span><span class="p">[</span><span class="mi">23</span><span class="p">];</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">IOMUXC_SW_MUX_CTL_PAD_UART1_CTS_B</span><span class="p">;</span>   
		<span class="p">};</span>   
</pre></div>
</div>
<p>  struct iomux  *iomux = ioremap(0x20e0000,  sizeof(struct iomux));</p>
<p>  对于GPIO，可以如下定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="p">{</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gdir</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">psr</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icr1</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">icr2</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">imr</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">isr</span><span class="p">;</span>   
			<span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">edge_sel</span><span class="p">;</span>   
		<span class="p">};</span>   
		<span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="o">*</span><span class="n">gpio1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x209C000</span><span class="p">,</span>  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
		<span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="o">*</span><span class="n">gpio5</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20AC000</span><span class="p">,</span>  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
</pre></div>
</div>
<p>  看一个驱动程序，先看它的入口函数，代码如下。</p>
<p>  第127行向上层驱动注册一个button_operations结构体，该结构体在第119～123行定义。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">119</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">button_operations</span> <span class="n">my_buttons_ops</span> <span class="o">=</span> <span class="p">{</span>   
		<span class="mi">120</span>    <span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>   
		<span class="mi">121</span>    <span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">board_imx6ull_button_init</span><span class="p">,</span>   
		<span class="mi">122</span>    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">board_imx6ull_button_read</span><span class="p">,</span>   
		<span class="mi">123</span> <span class="p">};</span>   
		<span class="mi">124</span>   
		<span class="mi">125</span> <span class="kt">int</span> <span class="nf">board_imx6ull_button_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>   
		<span class="mi">126</span> <span class="p">{</span>   
		<span class="mi">127</span>    <span class="n">register_button_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_buttons_ops</span><span class="p">);</span>   
		<span class="mi">128</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">129</span> <span class="p">}</span>   
</pre></div>
</div>
<p>  button_operations结构体中有init函数指针，它指向board_imx6ull_button_init函数，在里面将会初始化LED引脚：使能、设置为GPIO模式、设置为输出引脚。代码如下。</p>
<p>  值得关注的是第65～70行，对于寄存器要先使用ioremap得到它的虚拟地址，以后使用虚拟地址访问寄存器。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">50</span> <span class="cm">/* enable GPIO1,GPIO5 */</span>   
		<span class="mi">51</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">CCM_CCGR1</span><span class="p">;</span>   
		<span class="mi">52</span>   
		<span class="mi">53</span> <span class="cm">/* set GPIO5_IO03 as GPIO */</span>   
		<span class="mi">54</span> <span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1</span><span class="p">;</span>   
		<span class="mi">55</span>   
		<span class="mi">56</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">iomux</span> <span class="o">*</span><span class="n">iomux</span><span class="p">;</span>   
		<span class="mi">57</span>   
		<span class="mi">58</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="o">*</span><span class="n">gpio1</span><span class="p">;</span>   
		<span class="mi">59</span> <span class="k">static</span> <span class="k">struct</span> <span class="n">imx6ull_gpio</span> <span class="o">*</span><span class="n">gpio5</span><span class="p">;</span>   
		<span class="mi">60</span>   
		<span class="mi">61</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">board_imx6ull_button_init</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 初始化button, which-哪个button */</span>   
		<span class="mi">62</span> <span class="p">{</span>   
		<span class="mi">63</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CCM_CCGR1</span><span class="p">)</span>   
		<span class="mi">64</span>    <span class="p">{</span>   
		<span class="mi">65</span>       <span class="n">CCM_CCGR1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20C406C</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">66</span>       <span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x229000C</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>   
		<span class="mi">67</span>   
		<span class="mi">68</span>       <span class="n">iomux</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20e0000</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iomux</span><span class="p">));</span>   
		<span class="mi">69</span>       <span class="n">gpio1</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x209C000</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
		<span class="mi">70</span>       <span class="n">gpio5</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0x20AC000</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">imx6ull_gpio</span><span class="p">));</span>   
		<span class="mi">71</span>    <span class="p">}</span>   
		<span class="mi">72</span>   
		<span class="mi">73</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">74</span>    <span class="p">{</span>   
		<span class="mi">75</span>       <span class="cm">/* 1. enable GPIO5   </span>
<span class="cm">		76        * CG15, b[31:30] = 0b11   </span>
<span class="cm">		77        */</span>   
		<span class="mi">78</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">);</span>   
		<span class="mi">79</span>   
		<span class="mi">80</span>       <span class="cm">/* 2. set GPIO5_IO01 as GPIO   </span>
<span class="cm">		81        * MUX_MODE, b[3:0] = 0b101   </span>
<span class="cm">		82        */</span>   
		<span class="mi">83</span>       <span class="o">*</span><span class="n">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   
		<span class="mi">84</span>   
		<span class="mi">85</span>       <span class="cm">/* 3. set GPIO5_IO01 as input   </span>
<span class="cm">		86        * GPIO5 GDIR, b[1] = 0b0   </span>
<span class="cm">		87        */</span>   
		<span class="mi">88</span>       <span class="n">gpio5</span><span class="o">-&gt;</span><span class="n">gdir</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span>   
		<span class="mi">89</span>    <span class="p">}</span>   
		<span class="mi">90</span>    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>   
		<span class="mi">91</span>    <span class="p">{</span>   
		<span class="mi">92</span>       <span class="cm">/* 1. enable GPIO1   </span>
<span class="cm">		93        * CG13, b[27:26] = 0b11   </span>
<span class="cm">		94        */</span>   
		<span class="mi">95</span>       <span class="o">*</span><span class="n">CCM_CCGR1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">3</span><span class="o">&lt;&lt;</span><span class="mi">26</span><span class="p">);</span>   
		<span class="mi">96</span>   
		<span class="mi">97</span>       <span class="cm">/* 2. set GPIO1_IO18 as GPIO   </span>
<span class="cm">		98        * MUX_MODE, b[3:0] = 0b101   </span>
<span class="cm">		99        */</span>   
		<span class="mi">100</span>       <span class="n">iomux</span><span class="o">-&gt;</span><span class="n">IOMUXC_SW_MUX_CTL_PAD_UART1_CTS_B</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   
		<span class="mi">101</span>   
		<span class="mi">102</span>       <span class="cm">/* 3. set GPIO1_IO18 as input   </span>
<span class="cm">		103        * GPIO1 GDIR, b[18] = 0b0   </span>
<span class="cm">		104        */</span>   
		<span class="mi">105</span>       <span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">gdir</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">);</span>   
		<span class="mi">106</span>    <span class="p">}</span>   
		<span class="mi">107</span>   
		<span class="mi">108</span> <span class="p">}</span>   
</pre></div>
</div>
<p>  button_operations结构体中还有有read函数指针，它指向board_imx6ull_button_read函数，在里面将会读取并返回按键引脚的电平。代码如下。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		<span class="mi">110</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">board_imx6ull_button_read</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">)</span> <span class="cm">/* 读button, which-哪个 */</span>   
		<span class="mi">111</span> <span class="p">{</span>   
		<span class="mi">112</span>    <span class="c1">//printk(&quot;%s %s line %d, button %d, 0x%x\n&quot;, __FILE__, __FUNCTION__, __LINE__, which, *GPIO1_DATAIN);   </span>
		<span class="mi">113</span>    <span class="k">if</span> <span class="p">(</span><span class="n">which</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   
		<span class="mi">114</span>       <span class="k">return</span> <span class="p">(</span><span class="n">gpio5</span><span class="o">-&gt;</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">115</span>    <span class="k">else</span>   
		<span class="mi">116</span>       <span class="k">return</span> <span class="p">(</span><span class="n">gpio1</span><span class="o">-&gt;</span><span class="n">psr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>   
		<span class="mi">117</span> <span class="p">}</span>   
</pre></div>
</div>
</div>
</div>
<div class="section" id="id183">
<h4>测试<a class="headerlink" href="#id183" title="永久链接至标题">¶</a></h4>
<p>  先启动IMX6ULL QEMU模拟器，挂载NFS文件系统。</p>
<p>  运行QEMU时，</p>
<p>  QEMU内部为主机虚拟出一个网卡, IP为 10.0.2.2，</p>
<p>  IMX6ULL有一个网卡, IP为 10.0.2.15，</p>
<p>  它连接到主机的虚拟网卡。</p>
<p>  这样IMX6ULL就可以通过10.0.2.2去访问Ubuntu了。</p>
<p>  安装驱动程序之后执行测试程序，观察它的返回值(执行测试程序的同时操作按键)：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>	<span class="c1">#  insmod button_drv.ko   </span>
	<span class="c1">#  insmod board_drv.ko   </span>
	<span class="c1">#  insmod board_100ask_imx6ull-qemu.ko   </span>
	<span class="c1">#  ./button_test  /dev/100ask_button0   </span>
	<span class="c1">#  ./button_test  /dev/100ask_button1   </span>
</pre></div>
</div>
</div>
<div class="section" id="id184">
<h4>课后作业<a class="headerlink" href="#id184" title="永久链接至标题">¶</a></h4>
<p>  ① 修改button_test.c，使用按键来点灯</p>
</div>
</div>
</div>
<div class="section" id="id185">
<h2>异常与中断的概念及处理流程<a class="headerlink" href="#id185" title="永久链接至标题">¶</a></h2>
<div class="section" id="id186">
<h3>中断的引入<a class="headerlink" href="#id186" title="永久链接至标题">¶</a></h3>
<div class="section" id="id187">
<h4>妈妈怎么知道孩子醒了<a class="headerlink" href="#id187" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_110.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_110.png" />
&lt;400px&gt;</p>
<p>  妈妈怎么知道卧室里小孩醒了？</p>
<p>    ① 时时进房间看一下：查询方式</p>
<p>      简单，但是累</p>
<p>    ② 进去房间陪小孩一起睡觉，小孩醒了会吵醒她：休眠-唤醒</p>
<p>      不累，但是妈妈干不了活了</p>
<p>    ③ 妈妈要干很多活，但是可以陪小孩睡一会，定个闹钟：poll方式</p>
<p>      要浪费点时间，但是可以继续干活。</p>
<p>      妈妈要么是被小孩吵醒，要么是被闹钟吵醒。</p>
<p>    ④ 妈妈在客厅干活，小孩醒了他会自己走出房门告诉妈妈：异步通知</p>
<p>      妈妈、小孩互不耽误。</p>
<p>  后面的3种方式，都需要“小孩来中断妈妈”：中断她的睡眠、中断她的工作。</p>
<p>  实际上，能“中断”妈妈的事情可多了：</p>
<p>    ① 远处的猫叫：这可以被忽略</p>
<p>    ② 门铃、小孩哭声：妈妈的应对措施不一样</p>
<p>    ③ 身体不舒服：那要赶紧休息</p>
<p>    ④ 有蜘蛛掉下来了：赶紧跑啊，救命</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_145.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_145.png" />
&lt;600px&gt;</p>
<p>  妈妈当前正在看书，被“中断”后她会怎么做？流程如下：</p>
<p>    ① 妈妈正在看书</p>
<p>    ② 发生了各种声音</p>
<p>      可忽略的远处猫叫</p>
<p>      快递员按门铃</p>
<p>      卧室中小孩哭了</p>
<p>    ③ 妈妈怎么办？</p>
<p>      a. 先在书中放入书签，合上书</p>
<p>      b. 去处理</p>
<p>        对于不同的情况，处理方法不同：</p>
<p>        对于门铃：开门取快递</p>
<p>        对于哭声：照顾小孩</p>
<p>      c. 回来继续看书</p>
</div>
<div class="section" id="id188">
<h4>嵌入系统中也有类似的情况<a class="headerlink" href="#id188" title="永久链接至标题">¶</a></h4>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_146.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_146.png" />
&lt;600px&gt;</p>
<p>  CPU在运行的过程中，也会被各种“异常”打断。这些“异常”有：</p>
<p>    ① 指令未定义</p>
<p>    ② 指令、数据访问有问题</p>
<p>    ③ SWI(软中断)</p>
<p>    ④ 快中断</p>
<p>    ⑤ 中断</p>
<p>  中断也属于一种“异常”，导致中断发生的情况有很多，比如：</p>
<p>    ① 按键</p>
<p>    ② 定时器</p>
<p>    ③ ADC转换完成</p>
<p>    ④ UART发送完数据、收到数据</p>
<p>    ⑤ 等等</p>
<p>  这些众多的“中断源”，汇集到“中断控制器”，由“中断控制器”选择优先级最高的中断并通知CPU。</p>
</div>
</div>
<div class="section" id="id189">
<h3>中断的处理流程<a class="headerlink" href="#id189" title="永久链接至标题">¶</a></h3>
<p>  arm对异常(中断)处理过程：</p>
<p>    ① 初始化：</p>
<p>      a. 设置中断源，让它可以产生中断</p>
<p>      b. 设置中断控制器(可以屏蔽某个中断，优先级)</p>
<p>      c. 设置CPU总开关(使能中断)</p>
<p>    ② 执行其他程序：正常程序</p>
<p>    ③ 产生中断：比如按下按键—&gt;中断控制器—&gt;CPU</p>
<p>    ④ CPU 每执行完一条指令都会检查有无中断/异常产生</p>
<p>    ⑤ CPU发现有中断/异常产生，开始处理。</p>
<p>      对于不同的异常，跳去不同的地址执行程序。</p>
<p>      这地址上，只是一条跳转指令，跳去执行某个函数(地址)，这个就是异常向量。</p>
<p>      <font color="# dd0000">③④⑤都是硬件做的。</font></p>
<p>    ⑥ 这些函数做什么事情？</p>
<p>      软件做的:</p>
<p>        a. 保存现场(各种寄存器)</p>
<p>        b. 处理异常(中断):</p>
<p>          分辨中断源，再调用不同的处理函数</p>
<p>        c. 恢复现场</p>
</div>
<div class="section" id="id190">
<h3>异常向量表<a class="headerlink" href="#id190" title="永久链接至标题">¶</a></h3>
<p>  u-boot或是Linux内核，都有类似如下的代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>		 <span class="nl">_start</span><span class="p">:</span> <span class="n">b</span>	<span class="n">reset</span>   
		 	<span class="n">ldr</span>	<span class="n">pc</span><span class="p">,</span> <span class="n">_undefined_instruction</span>   
		 	<span class="n">ldr</span>	<span class="n">pc</span><span class="p">,</span> <span class="n">_software_interrupt</span>   
		 	<span class="n">ldr</span>	<span class="n">pc</span><span class="p">,</span> <span class="n">_prefetch_abort</span>   
		 	<span class="n">ldr</span>	<span class="n">pc</span><span class="p">,</span> <span class="n">_data_abort</span>   
		 	<span class="n">ldr</span>	<span class="n">pc</span><span class="p">,</span> <span class="n">_not_used</span>   
		 	<span class="n">ldr</span>	<span class="n">pc</span><span class="p">,</span> <span class="n">_irq</span> <span class="c1">//发生中断时，CPU跳到这个地址执行该指令 **假设地址为0x18**   </span>
		 	<span class="n">ldr</span>	<span class="n">pc</span><span class="p">,</span> <span class="n">_fiq</span>   
</pre></div>
</div>
<p>  这就是异常向量表，每一条指令对应一种异常。</p>
<p>  发生复位时，CPU就去 执行第1条指令：b  reset。</p>
<p>  发生中断时，CPU就去执行“ldr  pc, _irq”这条指令。</p>
<p>  这些指令存放的位置是固定的，比如对于ARM9芯片中断向量的地址是0x18。</p>
<p>  当发生中断时，CPU就强制跳去执行0x18处的代码。</p>
<p>  在向量表里，一般都是放置一条跳转指令，发生该异常时，CPU就会执行向量表中的跳转指令，去调用更复杂的函数。</p>
<p>  当然，向量表的位置并不总是从0地址开始，很多芯片可以设置某个vector base寄存器，指定向量表在其他位置，比如设置vector base为0x80000000，指定为DDR的某个地址。但是表中的各个异常向量的偏移地址，是固定的：复位向量偏移地址是0，中断是0x18。</p>
</div>
<div class="section" id="id191">
<h3>参考资料<a class="headerlink" href="#id191" title="永久链接至标题">¶</a></h3>
<p>  对于ARM的中断控制器，述语上称之为GIC (Generic Interrupt Controller)，到目前已经更新到v4版本了。</p>
<p>  各个版本的差别可以看这里：[https://developer.arm.com/ip-products/system-ip/system-controllers/interrupt-controllers https://developer.arm.com/ip-products/system-ip/system-controllers/interrupt-controllers](https://developer.arm.com/ip-products/system-ip/system-controllers/interrupt-controllers https://developer.arm.com/ip-products/system-ip/system-controllers/interrupt-controllers)</p>
<p>  简单地说，GIC v3/v4用于 ARMv8 架构，即64位ARM芯片。</p>
<p>  而GIC v2用于ARMv7和其他更低的架构。</p>
<p>  以后在驱动大全里讲解中断时，我们再深入分析，到时会涉及单核、多核等知识。</p>
</div>
</div>
<div class="section" id="id192">
<h2>常见问题<a class="headerlink" href="#id192" title="永久链接至标题">¶</a></h2>
<div class="section" id="version-magic">
<h3>安装驱动时version magic不匹配<a class="headerlink" href="#version-magic" title="永久链接至标题">¶</a></h3>
<p>  要想彻底了解内核的LOCALVERSION信息，可以看这个贴子：[https://blog.csdn.net/gatieme/article/details/78510497 https://blog.csdn.net/gatieme/article/details/78510497](https://blog.csdn.net/gatieme/article/details/78510497 https://blog.csdn.net/gatieme/article/details/78510497)</p>
<p>  总结一下：</p>
<p>    ① 开发板所用的内核版本：</p>
<p>     ;在开发板上执行“uname  -r”命令，可以得到开发板所用内核的版本，比如：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_147.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_147.png" />
&lt;200px&gt;</p>
<p>    ② 在服务器中给开发板编译内核时，这个内核也有一个版本：</p>
<p>     ;进入该内核源码目录，执行“make kernelrelease”命令，可以得到它的版本，比如：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_148.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_148.png" />
&lt;800px&gt;</p>
<p>    ③ 编译驱动时，会用到服务器中开发板的内核源码，会带有它的版本信息。</p>
<p>     如果①②③的版本信息不匹配，很可能导致驱动程序无法加载，比如：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_149.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_149.png" />
&lt;800px&gt;</p>
<p>  有2个解决方法：</p>
<p>    A. 在Ubuntu上重新编译内核，让开发板使用新的内核启动；重新编译驱动，加载新驱动：</p>
<p>     这样，①②③三者的内核版本就都一致了。</p>
<p>     但是，这种方法有时候不好用，比如开发板上的内核无法更改(出厂固化了)，或者你没有开发板上所用内核的全部源码无法编译出内核，这时就可以使用下面的方法。</p>
<p>    B. 在Ubuntu上修改版本号，改为开发板上“uname -r”的结果，然后重新编译内核和驱动：</p>
<p>     开发板就可以继续使用原来的内核，并且可以加载编译出来的驱动了。</p>
<p>  步骤如下：</p>
<p>    b.1 修改Ubuntu上开发板内核源码顶层目录Makefile，如下图：</p>
<p><img alt="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_150.png" src="https://weidongshan.readthedocs.io/zh_CN/latest/_images/EmbeddedLinuxApplicationDevelopmentCompleteManualSecondEditionChapterFive_150.png" />
&lt;600px&gt;</p>
<p>    b.2 重新编译内核，这会生成一些头文件，供驱动使用</p>
<p>    b.3 重新编译驱动</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="index.html" class="btn btn-neutral" title="&lt;no title&gt;" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2019, weidongshan www.100ask.net.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>